{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Adding-the-Composable-Architecture-as-a-dependency","level":2,"type":"heading","text":"Adding the Composable Architecture as a dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To use the Composable Architecture in a SwiftPM project, add it to the dependencies of your"},{"type":"text","text":" "},{"type":"text","text":"Package.swift and specify the "},{"type":"codeVoice","code":"ComposableArchitecture"},{"type":"text","text":" product in any targets that need access to"},{"type":"text","text":" "},{"type":"text","text":"the library:"}]},{"type":"codeListing","syntax":"swift","code":["let package = Package(","  dependencies: [","    .package(","      url: \"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\",","      from: \"0.39.0\"","    ),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [","        .product(","          name: \"ComposableArchitecture\",","          package: \"swift-composable-architecture\"","        )","      ]","    )","  ]",")"]},{"anchor":"Writing-your-first-feature","level":2,"type":"heading","text":"Writing your first feature"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To build a feature using the Composable Architecture you define some types and values that model"},{"type":"text","text":" "},{"type":"text","text":"your domain:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State"}]},{"type":"text","text":": A type that describes the data your feature needs to perform its logic and render its"},{"type":"text","text":" "},{"type":"text","text":"UI."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Action"}]},{"type":"text","text":": A type that represents all of the actions that can happen in your feature, such as"},{"type":"text","text":" "},{"type":"text","text":"user actions, notifications, event sources and more."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Environment"}]},{"type":"text","text":": A type that holds any dependencies the feature needs, such as API clients,"},{"type":"text","text":" "},{"type":"text","text":"analytics clients, etc."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Reducer"}]},{"type":"text","text":": A function that describes how to evolve the current state of the app to the next"},{"type":"text","text":" "},{"type":"text","text":"state given an action. The reducer is also responsible for returning any effects that should be"},{"type":"text","text":" "},{"type":"text","text":"run, such as API requests, which can be done by returning an "},{"type":"codeVoice","code":"Effect"},{"type":"text","text":" value."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Store"}]},{"type":"text","text":": The runtime that actually drives your feature. You send all user actions to the store"},{"type":"text","text":" "},{"type":"text","text":"so that the store can run the reducer and effects, and you can observe state changes in the"},{"type":"text","text":" "},{"type":"text","text":"store so that you can update UI."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The benefits of doing this is that you will instantly unlock testability of your feature, and you"},{"type":"text","text":" "},{"type":"text","text":"will be able to break large, complex features into smaller domains that can be glued together."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As a basic example, consider a UI that shows a number along with “+” and “−” buttons that increment"},{"type":"text","text":" "},{"type":"text","text":"and decrement the number. To make things interesting, suppose there is also a button that when"},{"type":"text","text":" "},{"type":"text","text":"tapped makes an API request to fetch a random fact about that number and then displays the fact in"},{"type":"text","text":" "},{"type":"text","text":"an alert."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The state of this feature would consist of an integer for the current count, as well as an optional"},{"type":"text","text":" "},{"type":"text","text":"string that represents the title of the alert we want to show (optional because "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" represents not"},{"type":"text","text":" "},{"type":"text","text":"showing an alert):"}]},{"type":"codeListing","syntax":"swift","code":["struct AppState: Equatable {","  var count = 0","  var numberFactAlert: String?","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next we have the actions in the feature. There are the obvious actions, such as tapping the"},{"type":"text","text":" "},{"type":"text","text":"decrement button, increment button, or fact button. But there are also some slightly non-obvious"},{"type":"text","text":" "},{"type":"text","text":"ones, such as the action of the user dismissing the alert, and the action that occurs when we"},{"type":"text","text":" "},{"type":"text","text":"receive a response from the fact API request:"}]},{"type":"codeListing","syntax":"swift","code":["enum AppAction: Equatable {","  case factAlertDismissed","  case decrementButtonTapped","  case incrementButtonTapped","  case numberFactButtonTapped","  case numberFactResponse(TaskResult<String>)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next we model the environment of dependencies this feature needs to do its job. In particular, to"},{"type":"text","text":" "},{"type":"text","text":"fetch a number fact we can model an async throwing function from "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" to "},{"type":"codeVoice","code":"String"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct AppEnvironment {","  var numberFact: (Int) async throws -> String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we implement a reducer that implements the logic for this domain. It describes how to change"},{"type":"text","text":" "},{"type":"text","text":"the current state to the next state, and describes what effects need to be executed. Some actions"},{"type":"text","text":" "},{"type":"text","text":"don’t need to execute effects, and they can return "},{"type":"codeVoice","code":".none"},{"type":"text","text":" to represent that:"}]},{"type":"codeListing","syntax":"swift","code":["let appReducer = Reducer<","  AppState,","  AppAction,","  AppEnvironment","> { state, action, environment in","  switch action {","  case .factAlertDismissed:","    state.numberFactAlert = nil","    return .none","","  case .decrementButtonTapped:","    state.count -= 1","    return .none","","  case .incrementButtonTapped:","    state.count += 1","    return .none","","  case .numberFactButtonTapped:","    return .task { [count = state.count] in","      await .numberFactResponse(","        TaskResult { try await environment.numberFact(count) }","      )","    }","","  case let .numberFactResponse(.success(fact)):","    state.numberFactAlert = fact","    return .none","","  case .numberFactResponse(.failure):","    state.numberFactAlert = \"Could not load a number fact :(\"","    return .none","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then finally we define the view that displays the feature. It holds onto a"},{"type":"text","text":" "},{"type":"codeVoice","code":"Store<AppState, AppAction>"},{"type":"text","text":" so that it can observe all changes to the state and re-render, and we"},{"type":"text","text":" "},{"type":"text","text":"can send all user actions to the store so that state changes. We must also introduce a struct"},{"type":"text","text":" "},{"type":"text","text":"wrapper around the fact alert to make it "},{"type":"codeVoice","code":"Identifiable"},{"type":"text","text":", which the "},{"type":"codeVoice","code":".alert"},{"type":"text","text":" view modifier requires:"}]},{"type":"codeListing","syntax":"swift","code":["struct AppView: View {","  let store: Store<AppState, AppAction>","","  var body: some View {","    WithViewStore(self.store, observe: { $0 }) { viewStore in","      VStack {","        HStack {","          Button(\"−\") { viewStore.send(.decrementButtonTapped) }","          Text(\"\\(viewStore.count)\")","          Button(\"+\") { viewStore.send(.incrementButtonTapped) }","        }","","        Button(\"Number fact\") { viewStore.send(.numberFactButtonTapped) }","      }","      .alert(","        item: viewStore.binding(","          get: { $0.numberFactAlert.map(FactAlert.init(title:)) },","          send: .factAlertDismissed","        ),","        content: { Alert(title: Text($0.title)) }","      )","    }","  }","}","","struct FactAlert: Identifiable {","  var title: String","  var id: String { self.title }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s important to note that we were able to implement this entire feature without having a real,"},{"type":"text","text":" "},{"type":"text","text":"live effect at hand. This is important because it means features can be built in isolation without"},{"type":"text","text":" "},{"type":"text","text":"building their dependencies, which can help compile times."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we are ready to display this view, for example in the app’s entry point, we can construct a"},{"type":"text","text":" "},{"type":"text","text":"store. This is the moment where we need to supply the dependencies, including the "},{"type":"codeVoice","code":"numberFact"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"endpoint that actually reaches out into the real world to fetch the fact:"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct CaseStudiesApp: App {","var body: some Scene {","  AppView(","    store: Store(","      initialState: AppState(),","      reducer: appReducer,","      environment: AppEnvironment(","        numberFact: { number in ","          let (data, _) = try await URLSession.shared","            .data(from: .init(string: \"http:\/\/numbersapi.com\/\\(number)\")!)","          return String(decoding: data, using: UTF8.self)","        }","      )","    )","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And that is enough to get something on the screen to play around with. It’s definitely a few more"},{"type":"text","text":" "},{"type":"text","text":"steps than if you were to do this in a vanilla SwiftUI way, but there are a few benefits. It gives"},{"type":"text","text":" "},{"type":"text","text":"us a consistent manner to apply state mutations, instead of scattering logic in some observable"},{"type":"text","text":" "},{"type":"text","text":"objects and in various action closures of UI components. It also gives us a concise way of"},{"type":"text","text":" "},{"type":"text","text":"expressing side effects. And we can immediately test this logic, including the effects, without"},{"type":"text","text":" "},{"type":"text","text":"doing much additional work."}]},{"anchor":"Testing-your-feature","level":2,"type":"heading","text":"Testing your feature"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To test, you first create a "},{"type":"codeVoice","code":"TestStore"},{"type":"text","text":" with the same information that you would to create a regular"},{"type":"text","text":" "},{"type":"codeVoice","code":"Store"},{"type":"text","text":", except this time we can supply test-friendly dependencies. In particular, we can now use a"},{"type":"text","text":" "},{"type":"codeVoice","code":"numberFact"},{"type":"text","text":" implementation that immediately returns a value we control rather than reaching out"},{"type":"text","text":" "},{"type":"text","text":"into the real world:"}]},{"type":"codeListing","syntax":"swift","code":["func testFeature() async {","  let store = TestStore(","    initialState: AppState(),","    reducer: appReducer,","    environment: AppEnvironment(","      numberFact: { \"\\($0) is a good number Brent\" }","    )","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once the test store is created we can use it to make an assertion of an entire user flow of steps."},{"type":"text","text":" "},{"type":"text","text":"Each step of the way we need to prove that state changed how we expect. Further, if a step causes an"},{"type":"text","text":" "},{"type":"text","text":"effect to be executed, which feeds data back into the store, we must assert that those actions were"},{"type":"text","text":" "},{"type":"text","text":"received properly."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The test below has the user increment and decrement the count, then they ask for a number fact, and"},{"type":"text","text":" "},{"type":"text","text":"the response of that effect triggers an alert to be shown, and then dismissing the alert causes the"},{"type":"text","text":" "},{"type":"text","text":"alert to go away."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Test that tapping on the increment\/decrement buttons changes the count","await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.decrementButtonTapped) {","  $0.count = 0","}","","\/\/ Test that tapping the fact button causes us to receive a response from the effect. Note","\/\/ that we have to await the receive because the effect is asynchronous and so takes a small","\/\/ amount of time to emit.","await store.send(.numberFactButtonTapped)","","await store.receive(.numberFactResponse(.success(\"0 is a good number Brent\"))) {","  $0.numberFactAlert = \"0 is a good number Brent\"","}","","\/\/ And finally dismiss the alert","await store.send(.factAlertDismissed) {","  $0.numberFactAlert = nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is the basics of building and testing a feature in the Composable Architecture. There are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"a"},{"type":"text","text":" "},{"type":"text","text":"lot"}]},{"type":"text","text":" more things to be explored, such as composition, modularity, adaptability, and complex effects."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Getting started","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingReadyForSwiftConcurrency","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"],"generated":true}],"references":{"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/GettingReadyForSwiftConcurrency":{"role":"article","title":"Getting ready for Swift concurrency","abstract":[{"type":"text","text":"Learn how to write safe, concurrent effects using Swift’s structured concurrency."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingReadyForSwiftConcurrency","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingreadyforswiftconcurrency"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/testing"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"role":"article","title":"Performance","abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/performance"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"}}}