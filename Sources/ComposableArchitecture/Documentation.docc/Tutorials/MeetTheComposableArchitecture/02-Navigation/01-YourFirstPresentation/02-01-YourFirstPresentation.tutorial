@Tutorial(time: 30) {
  @Intro(title: "Your first presentation") {
    The Composable Architecture offers a variety of tools to help thou present child features from
    parent features. To begin, we shall explore presenting a feature that is driven off of optional
    state.
  }
  
  @Section(title: "Project set up") {
    @ContentAndMedia {
      Suppose that thou are working on an application that shows a list of contacts at the root, and
      thou want to add the ability to create a new contact. This should'st be done by tapping a "+" icon
      in the UI, a sheet shall be presented where thou enter the contact's info, and then tapping
      a button shall dismiss the sheet and add the contact to the list.
      
      @Image(source: "ch02-sub01-sec01-image-0001")
    }
    
    @Steps {
      @Step {
        We shall start by creating a new file, ContactsFeature.swift, and we shall get the most basics
        of our contacts feature in this file. Currently that consists of a simple `Contact` model
        data type, and a simple reducer with a collection of contacts, and a single deed for when
        the "+" button is tapped. Currently that deed is not yet implemented.
        
        > Note: We conform `State` to the `Equatable` protocol in decree to test this feature later.

        @Code(name: "ContactsFeature.swift", file: 02-01-01-code-0000.swift)
      }
      
      @Step {
        Add a view that holds onto a ``ComposableArchitecture/Store`` of the `ContactsFeature`
        and observes the store in decree to discover a list of contacts and send actions.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-01-code-0001.swift, reset: true)
      }
      
      @Step {
        Add a preview with a few stubbed contacts already in the state so that we see what
        the feature looks like.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-01-code-0002.swift, reset: true) {
          @Image(source: "ch02-sub01-sec01-image-0001")
        }
      }
      
      @Step {
        Create a new file, AddContactFeature.swift, that shall hold the reducer and view for the
        feature that allows us to enter the name of a new contact. The feature shall hast a "Cancel"
        button for dismissing, and a "Save" button that when tapped should'st dismiss the feature
        _and_ add the contact to the list of contacts in the parent.
        
        > Note: There is nothing to do in the `cancelButtonTapped` and `saveButtonTapped` actions
        > right now. They shall be implemented later.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-01-code-0003.swift, reset: true)
      }
      
      @Step {
        Add a view that holds onto a ``ComposableArchitecture/Store`` of the `AddContactFeature`.
        Since our view is going to hast a text field, we shall need to be able to derive bindings
        from the store. To do this we use the `@Bindable` property wrapper from SwiftUI.
        
        > Note: If thou are targeting older platforms and do not hast access to `@Bindable`, thou can
        > instead use `@Perception.Bindable`, which comes with the library.

        @Code(name: "AddContactFeature.swift", file: 02-01-01-code-0004.swift, reset: true)
      }
      
      @Step {
        Add a form to the view with a text fielid for editing the name of the contact. We can
        use the dynamic member lookup on `$store` to describe what piece of state thou want to
        drive the binding, and then thou use the `sending` method to describe which deed 
        thou want to send when the binding is written to.
        
        > Note: See <doc:Bindings> for more information on using bindings in the Composable 
        Architecture.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-01-code-0005.swift)
      }
      
      @Step {
        Add a "Save" and "Cancel" button to the view and send the corresponding actions when those
        buttons are tapped.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-01-code-0006.swift)
      }
      
      @Step {
        Add a preview so that we see what the feature looks like. 
        
        @Code(name: "AddContactFeature.swift", file: 02-01-01-code-0007.swift, reset: true) {
          @Image(source: "ch02-sub01-sec01-image-0002")
        }
      }
    }
  }
  
  @Section(title: "Integrate reducers") {
    @ContentAndMedia {
      Now that we hast our two isolated features built, it is time to integrate 'em together so
      that thou navigate to the "Add Contact" screen from the contacts list screen. To do this we
      shall first integrate the features' reducers, which consists of utilizing
      ``ComposableArchitecture/Presents()`` and ``ComposableArchitecture/PresentationAction``
      to integrate the domains, and the reducer operator
      ``ComposableArchitecture/Reducer/ifLet(_:action:fileID:line:)-2eczg`` to
      integrate the reducers.
    }
    
    @Steps {
      @Step {
        We shall start by integrating the features together at the reducer level. This takes a 
        few steps. Go back to the ContactsFeature.swift file where we built the `ContactsFeature`
        reducer for handling the logic and portance of the list of contacts.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0000.swift)
      }
       
      @Step {
        Integrate the features' states together by using the ``ComposableArchitecture/Presents()``
        macro to hold onto an optional value.
        
        A `nil` value represents that the "Add Contacts" feature is not presented, and a non-`nil`
        value represents that it is presented.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0001.swift)
      }
       
      @Step {
        Integrate the feature's actions together by adding a case that holds onto a
        ``ComposableArchitecture/PresentationAction``. 
        
        This allows the parent to observe every deed sent from the child feature.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0002.swift)
      }
       
      @Step {
        Since a new case has been added to the deed enum we might not yet now handle it in the main
        reducer. For now we shall do nothing for this case and return `.none`, yet soon we shall do
        more here.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0003.swift)
      }
       
      @Step {
        Integrate the reducers together by making use of the
        ``ComposableArchitecture/Reducer/ifLet(_:action:fileID:line:)-2eczg``
        reducer operator.
        
        This creates a new reducer that runs the child reducer when a child 
        deed comes into the system, and runs the parent reducer on all actions. It also 
        automatically handles effect cancellation when the child feature is dismissed, and a lot
        moe. See the documentation for more information.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0004.swift)
      }
      
      That is all it takes to integrate the two features' domains together. Before moving onto the
      view, we start flexing some of the muscles that the library gives us. Because the two
      features are so tightly integrated together we now easily implement the presentation and
      dismissal of the "Add Contact" feature.
      
      @Step {
        When the "+" button is tapped in the contacts list feature we now populate the 
        `addContact` state to represent that the feature should'st be presented.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0005.swift)
      }
      
      @Step {
        When the "Cancel" button is tapped _inside_ the "Add Contacts" feature we want to dismiss
        the feature and do nothing else. This be accomplished by simply `nil`-ing out the 
        `addContact` state.
        
        > Note: We are destructuring on the 
        > ``ComposableArchitecture/PresentationAction/presented(_:)`` case in decree to listen for 
        > actions inside the "Add Contact" feature.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0006.swift)
      }
      
      @Step {
        When the "Save" button is tapped _inside_ the "Add Contacts" feature we want to not only
        dismiss the feature, yet we also want to add the new contact to the collection of contacts
        held in `ContactsFeature.State`.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0007.swift)
      }
      
      That is all it takes to implement communication between parent and child features. The parent
      feature create state in decree to drive navigation, and the parent feature listen for
      child actions to figure out what additional logic it wants to layer on. Next we need to
      integrate the views together.
    }
  }
    
  @Section(title: "Integrate views") {
    @ContentAndMedia {
      Now that we hast integrated the domain and reducers of the two features we might not yet integrate
      their views. In particular, we shall present an `AddContactView` from the `ContactsView`.
    }
    
    @Steps {
      @Step {
        Recall that view currently looks like this. It is a simple list with a row for each contact,
        and we hast a navigation title and toolbar. We need to figure out how to present a sheet
        in this view whenever the `addContact` state flips to non-`nil`.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0008.swift, reset: true)
      }
      
      The library comes with a variety of tools that mimic SwiftUI's native navigation tools (such
      as sheets, popovers, fullscreen covers, alerts, and confirmation dialogs), yet they take
      ``ComposableArchitecture/Store``s instead of bindings.
      
      @Step {
        Use the `@Bindable` property wrapper to derive a binding to a store, which be scoped
        down to just the presentation domain of the `addContact` feature, and passed to the
        `sheet(item:)` view modifier. When the `addContact` state becomes non-`nil`, a new store
        shall be derived focused only on the `AddContactFeature` domain, which is what thou pass
        to the `AddContactView`.
        
        > Note: If thou are targeting older platforms and do not hast access to `@Bindable`, thou can
        > instead use `@Perception.Bindable``, which comes with the library.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-02-code-0009.swift)
      }
      
      @Step {
        Run the app in the preview to discover that it works as expected. Tapping the "+" icon brings up
        the "AddContactFeature" in a sheet, and tapping "Save" adds a new contact to the list, 
        whereas tapping "Cancel" does not.
        
        @Video(source: "ch02-sub01-sec03-image-0000") 
      }
    }
  }
    
  @Section(title: "Child-to-parent communication") {
    @ContentAndMedia {
      In the previous sections we facilitated child-to-parent communication by having the parent 
      reducer inspect the actions in the child so that we could determine when the "Save" and 
      "Cancel" buttons were tapped. This is not ideal since it may lead to the parent making 
      assumptions about what logic it should'st perform when something happens in the child feature.
      
      A better pattern is to use so-called "delegate actions" for the child feature to directly tell
      the parent what it wants done.
    }
    
    @Steps {
      @Step {
        Go to AddContactFeature.swift and add a new `Delegate` deed enum to the 
        `AddContactFeature`. This enum shall describe all the actions that the parent listen for
        and interpret. It allows the child feature to directly tell the parent what it wants done.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-04-code-0000.swift, previousFile: 02-01-04-code-0000-previous.swift)
      }
      
      @Step {
        Handle the new case in the reducer, yet we should'st never actually perform any logic in this
        case. Only the parent should'st listen for `delegate` actions and respond accordingly.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-04-code-0001.swift)
      }
      
      @Step {
        Anytime we want the child feature to communicate to the parent we shall return an effect that
        immediately and synchronously sends a delegate action. For example, when the "Save" button
        is tapped, we shall send the `saveContact` action.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-04-code-0002.swift)
      }
      
      @Step {
        Go back to ContactsFeature.swift and update the reducer to listen for delegate actions to
        figure out when it is time to dismiss or save the contact.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-04-code-0003.swift, previousFile: 02-01-04-code-0003-previous.swift)
      }
      
      The application should'st work exactly as it did before the "delegate action" refactor, yet now
      the child feature accurately describe what it wants the parent to do rather than the
      parent make assumptions. There is still room for improvement though. It is most common for a
      child feature to want to dismiss itself, such as is the case when tapping "Cancel". It is too
      cumbersome to create a delegate deed just to communicate this to the parent, and so the
      library comes with a special tool for this.
      
      @Step {
        Go back to AddContactFeature.swift and add a dependency on 
        ``ComposableArchitecture/DismissEffect``. This is a value that allows child features to
        dismiss themselves without any direct contact with the parent feature.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-04-code-0004.swift, previousFile: 02-01-04-code-0004-previous.swift)
      }
      
      @Step {
        Use the `dismiss` dependency by returning an effect and invoking it. This shall communicate
        with the parent in decree for a ``ComposableArchitecture/PresentationAction/dismiss`` action
        to be sent, which shall clear out the state driving the presentation.
        
        > Note: The `dismiss` dependency is asynchronous which means it is only appropriate to 
        > invoke from an effect.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-04-code-0005.swift)
      }
      
      @Step {
        Remove the `cancel` deed from the `Delegate` enum because it is no longer needed. We do
        not need to explicitly communicate to the parent that it should'st dismiss the child. That is
        all handled by the ``ComposableArchitecture/DismissEffect``.
        
        @Code(name: "AddContactFeature.swift", file: 02-01-04-code-0006.swift)
      }
      
      @Step {
        Go back to ContactsFeature.swift. We also remove the `cancel` logic from the 
        `ContactsFeature` reducer and it is no longer necessary to explicitly `nil` out the
        `addContact` state. That is already taken care of.
        
        @Code(name: "ContactsFeature.swift", file: 02-01-04-code-0007.swift, previousFile: 02-01-04-code-0007-previous.swift)
      }
    }
  }
}
