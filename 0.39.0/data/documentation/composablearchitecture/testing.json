{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The testability of features built in the Composable Architecture is the #1 priority of the library."},{"type":"text","text":" "},{"type":"text","text":"We never want to introduce new capabilities to the library that make testing more difficult."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Testing-state-changes"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Testing-effects"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Designing-dependencies"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"overridingTitleInlineContent":[{"type":"text","text":"Unimplemented dependencies"}],"isActive":true,"type":"reference","identifier":"#Designing-dependencies","overridingTitle":"Unimplemented dependencies"}]}]}]},{"anchor":"Testing-state-changes","level":2,"type":"heading","text":"Testing state changes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"State changes are by far the simplest thing to test in features built with the library. A"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":"’s first responsibility is to mutate the current state based on the action received into"},{"type":"text","text":" "},{"type":"text","text":"the system. To test this we can technically run a piece of mutable state through the reducer and"},{"type":"text","text":" "},{"type":"text","text":"then assert on how it changed after, like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct State: Equatable { var count = 0 }","enum Action { case incrementButtonTapped, decrementButtonTapped }","struct Environment {}","","let counter = Reducer<State, Action, Environment> { state, action, environment in","  switch action {","  case .incrementButtonTapped:","    state.count += 1","    return .none","  case .decrementButtonTapped:","    state.count -= 1","    return .none","  }","}","","let environment = Environment()","var currentState = State(count: 0)","","_ = reducer(&currentState, .incrementButtonTapped, environment)","","XCTAssertEqual(","  currentState,","  State(count: 1)",")","","_ = reducer(&currentState, .decrementButtonTapped, environment)","","XCTAssertEqual(","  currentState,","  State(count: 0)",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will technically work, but it’s a lot boilerplate for something that should be quite simple."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a tool specifically designed to make testing like this much simpler and more"},{"type":"text","text":" "},{"type":"text","text":"concise. It’s called "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":", and it is constructed similarly to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"type":"text","text":" by providing the"},{"type":"text","text":" "},{"type":"text","text":"initial state of the feature, the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":" that run’s the feature’s logic, and an environment of"},{"type":"text","text":" "},{"type":"text","text":"dependencies for the feature to use:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","class CounterTests: XCTestCase {","  func testBasics() async {","    let store = TestStore(","      initialState: State(count: 0),","      reducer: counter,","      environment: Environment()","    )","  }","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Test cases that use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" should be annotated as "},{"type":"codeVoice","code":"@MainActor"},{"type":"text","text":" and test methods should be"},{"type":"text","text":" "},{"type":"text","text":"marked as "},{"type":"codeVoice","code":"async"},{"type":"text","text":" since most assertion helpers on "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" can suspend."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test stores have a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:_:file:line:)-7vwv9"},{"type":"text","text":" method, but it behaves differently from"},{"type":"text","text":" "},{"type":"text","text":"stores and view stores. You provide an action to send into the system, but then you must also"},{"type":"text","text":" "},{"type":"text","text":"provide a trailing closure to describe how the state of the feature changed after sending the"},{"type":"text","text":" "},{"type":"text","text":"action:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  …","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This closure is handed a mutable variable that represents the state of the feature "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"type":"text","text":" sending"},{"type":"text","text":" "},{"type":"text","text":"the action, and it is your job to make the appropriate mutations to it to get it into the shape"},{"type":"text","text":" "},{"type":"text","text":"it should be after sending the action:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  $0.count = 1","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:_:file:line:)-7vwv9"},{"type":"text","text":" method is "},{"type":"codeVoice","code":"async"},{"type":"text","text":" for technical reasons that we do"},{"type":"text","text":" "},{"type":"text","text":"not have to worry about right now."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your mutation is incorrect, meaning you perform a mutation that is different from what happened"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":", then you will get a test failure with a nicely formatted message showing exactly"},{"type":"text","text":" "},{"type":"text","text":"what part of the state does not match:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  $0.count = 999","}"]},{"type":"codeListing","syntax":null,"code":["🛑 testSomething(): A state change does not match expectation: …","","  − TestStoreTests.State(count: 999)","  + TestStoreTests.State(count: 1)","","(Expected: −, Actual: +)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also send multiple actions to emulate a script of user actions and assert each step of the"},{"type":"text","text":" "},{"type":"text","text":"way how the state evolved:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.incrementButtonTapped) {","  $0.count = 2","}","await store.send(.decrementButtonTapped) {","  $0.count = 1","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Technically we could have written the mutation block in the following manner:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  $0.count += 1","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"…and the test would have still passed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, this does not produce as strong of an assertion. It shows that the count did increment"},{"type":"text","text":" "},{"type":"text","text":"by one, but we haven’t proven we know the precise value of "},{"type":"codeVoice","code":"count"},{"type":"text","text":" at each step of the way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In general, the less logic you have in the trailing closure of"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:_:file:line:)-7vwv9"},{"type":"text","text":", the stronger your assertion will be. It is best to use"},{"type":"text","text":" "},{"type":"text","text":"simple, hard coded data for the mutation."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test stores do expose a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state"},{"type":"text","text":" property, which can be useful for performing assertions"},{"type":"text","text":" "},{"type":"text","text":"on computed properties you might have defined on your state. However, when inside the trailing"},{"type":"text","text":" "},{"type":"text","text":"closure of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:_:file:line:)-7vwv9"},{"type":"text","text":", the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state"},{"type":"text","text":" property is equal"},{"type":"text","text":" "},{"type":"text","text":"to the state "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"type":"text","text":" sending the action, not after. That prevents you from being able to use an"},{"type":"text","text":" "},{"type":"text","text":"escape hatch to get around needing to actually describe the state mutation, like so:"}]},{"type":"codeListing","syntax":"swift","code":["store.send(.incrementButtonTapped) {","  $0 = store.state \/\/ 🛑 store.state is the previous state, not new state.","}"]},{"anchor":"Testing-effects","level":2,"type":"heading","text":"Testing effects"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Testing state mutations as shown in the previous section is powerful, but is only half the story"},{"type":"text","text":" "},{"type":"text","text":"when it comes to testing features built in the Composable Architecture. The second responsibility of"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":"s, after mutating state from an action, is to return an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":" that encapsulates a"},{"type":"text","text":" "},{"type":"text","text":"unit of work that runs in the outside world and feeds data back into the system."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Effects form a major part of a feature’s logic. They can perform network requests to external"},{"type":"text","text":" "},{"type":"text","text":"services, load and save data to disk, start and stop timers, interact with Apple frameworks (Core"},{"type":"text","text":" "},{"type":"text","text":"Location, Core Motion, Speech Recognition, etc.), and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As a simple example, suppose we have a feature with a button such that when you tap it it starts"},{"type":"text","text":" "},{"type":"text","text":"a timer that counts up until you reach 5, and then stops. This can be accomplished using the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect\/run(priority:operation:catch:file:fileID:line:)"},{"type":"text","text":" helper, which provides you an"},{"type":"text","text":" "},{"type":"text","text":"asynchronous context to operate in and can send multiple actions back into the system:"}]},{"type":"codeListing","syntax":"swift","code":["struct State: Equatable { var count = 0 }","enum Action {  case startTimerButtonTapped, timerTick }","struct Environment {}","","let reducer = Reducer<State, Action, Environment> { state, action, environment in","  enum TimerID {}","","  switch action {","  case .startTimerButtonTapped:","    state.count = 0","    return .run { send in","      for _ in 1...5 {","        try await Task.sleep(nanoseconds: NSEC_PER_SEC)","        await send(.timerTick)","      }","    }","","  case .timerTick:","    state.count += 1","    return .none","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To test this we can start off similar to how we did in the "},{"overridingTitleInlineContent":[{"type":"text","text":"previous section"}],"isActive":true,"type":"reference","identifier":"#Testing-state-changes","overridingTitle":"previous section"},{"type":"text","text":" "},{"type":"text","text":"when testing state mutations:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","class TimerTests: XCTestCase {","  func testBasics() async {","    let store = TestStore(","      initialState: State(count: 0),","      reducer: reducer,","      environment: Environment()","    )","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With the basics set up, we can send an action into the system to assert on what happens, such as the"},{"type":"text","text":" "},{"type":"codeVoice","code":".startTimerButtonTapped"},{"type":"text","text":" action. This time we don’t actually expect state to change at first"},{"type":"text","text":" "},{"type":"text","text":"because when starting the timer we don’t change state, and so in this case we can leave off the"},{"type":"text","text":" "},{"type":"text","text":"trailer closure:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.startTimerButtonTapped)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if we run the test as-is with no further interactions with the test store, we get a"},{"type":"text","text":" "},{"type":"text","text":"failure:"}]},{"type":"codeListing","syntax":null,"code":["🛑 testSomething(): An effect returned for this action is still running.","   It must complete before the end of the test. …"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is happening because "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" requires you to exhaustively prove how the entire system"},{"type":"text","text":" "},{"type":"text","text":"of your feature evolves over time. If an effect is still running when the test finishes and the"},{"type":"text","text":" "},{"type":"text","text":"test store does "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" fail then it could be hiding potential bugs. Perhaps the effect is not"},{"type":"text","text":" "},{"type":"text","text":"supposed to be running, or perhaps the data it feeds into the system later is wrong. The test store"},{"type":"text","text":" "},{"type":"text","text":"requires all effects to finish."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To get this test passing we need to assert on the actions that are sent back into the system"},{"type":"text","text":" "},{"type":"text","text":"by the effect. We do this by using the "},{"type":"codeVoice","code":"TestStore\/receive(_:timeout:_:file:line:)-88eyr"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"which allows you to assert which action you expect to receive from an effect, as well as how the"},{"type":"text","text":" "},{"type":"text","text":"state changes after receiving that effect:"}]},{"type":"codeListing","syntax":"swift","code":["await store.receive(.timerTick) {","  $0.count = 1","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if we run this test we still get a failure because we asserted a "},{"type":"codeVoice","code":"timerTick"},{"type":"text","text":" action was"},{"type":"text","text":" "},{"type":"text","text":"going to be received, but after waiting around for a small amount of time no action was received:"}]},{"type":"codeListing","syntax":null,"code":["🛑 testSomething(): Expected to receive an action, but received none after 0.1 seconds."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is because our timer is on a 1 second interval, and by default"},{"type":"text","text":" "},{"type":"codeVoice","code":"TestStore\/receive(_:timeout:_:file:line:)-88eyr"},{"type":"text","text":" only waits for a fraction of a second. This is"},{"type":"text","text":" "},{"type":"text","text":"because typically you should not be performing real time-based asynchrony in effects, and instead"},{"type":"text","text":" "},{"type":"text","text":"using a controlled entity, such as a scheduler or clock, that can be sped up in tests. We will"},{"type":"text","text":" "},{"type":"text","text":"demonstrate this in a moment, so for now let’s increase the timeout:"}]},{"type":"codeListing","syntax":"swift","code":["await store.receive(.timerTick, timeout: 2*NSEC_PER_SEC) {","  $0.count = 1","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This assertion now passes, but the overall test is still failing because there are still more"},{"type":"text","text":" "},{"type":"text","text":"actions to receive. The timer should tick 5 times in total, so we need five "},{"type":"codeVoice","code":"receive"},{"type":"text","text":" assertions:"}]},{"type":"codeListing","syntax":"swift","code":["await store.receive(.timerTick, timeout: 2*NSEC_PER_SEC) {","  $0.count = 1","}","await store.receive(.timerTick, timeout: 2*NSEC_PER_SEC) {","  $0.count = 2","}","await store.receive(.timerTick, timeout: 2*NSEC_PER_SEC) {","  $0.count = 3","}","await store.receive(.timerTick, timeout: 2*NSEC_PER_SEC) {","  $0.count = 4","}","await store.receive(.timerTick, timeout: 2*NSEC_PER_SEC) {","  $0.count = 5","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the full test suite passes, and we have exhaustively proven how effects are executed in this"},{"type":"text","text":" "},{"type":"text","text":"feature. If in the future we tweak the logic of the effect, like say have it emit some number of"},{"type":"text","text":" "},{"type":"text","text":"times different from 5, then we will immediately get a test failure letting us know that we have"},{"type":"text","text":" "},{"type":"text","text":"not properly asserted on how the features evolves over time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there is something not ideal about how this feature is structured, and that is the fact"},{"type":"text","text":" "},{"type":"text","text":"that we are doing actual, uncontrolled time-based asynchrony in the effect:"}]},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  for _ in 1...5 {","    try await Task.sleep(nanoseconds: NSEC_PER_SEC)","    await send(.timerTick)","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This means for our test to run we must actually wait for 5 real world seconds to pass so that we"},{"type":"text","text":" "},{"type":"text","text":"can receive all of the actions from the timer. This makes our test suite far too slow. What if in"},{"type":"text","text":" "},{"type":"text","text":"the future we need to test a feature that has a timer that emits hundreds or thousands of times?"},{"type":"text","text":" "},{"type":"text","text":"We cannot hold up our test suite for minutes or hours just to test that one feature."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To fix this we need to hold onto a dependency in the feature’s environment that aids in performing"},{"type":"text","text":" "},{"type":"text","text":"time-based asynchrony, but in a way that is controllable. One way to do this is to add a Combine"},{"type":"text","text":" "},{"type":"text","text":"scheduler to the environment:"}]},{"type":"codeListing","syntax":"swift","code":["import CombineSchedulers","","struct Environment {","  var mainQueue: any SchedulerOf<DispatchQueue>","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To make use of controllable schedulers you must use the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/combine-schedulers"},{"type":"text","text":" library, which is automatically included with the"},{"type":"text","text":" "},{"type":"text","text":"Composable Architecture."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then the timer effect in the reducer can make use of the scheduler to sleep rather than reaching"},{"type":"text","text":" "},{"type":"text","text":"out to the uncontrollable "},{"type":"codeVoice","code":"Task.sleep"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  for _ in 1...5 {","    try await environment.mainQueue.sleep(for: .seconds(1))","    await send(.timerTick)","  }","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"sleep(for:)"},{"type":"text","text":" method on "},{"type":"codeVoice","code":"Scheduler"},{"type":"text","text":" is provided by the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"Combine Schedulers"}],"isActive":true,"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/combine-schedulers","overridingTitle":"Combine Schedulers"},{"type":"text","text":" library."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By having a scheduler in the environment we can supply a controlled value in tests, such as an"},{"type":"text","text":" "},{"type":"text","text":"immediate scheduler that does not suspend at all when you ask it to sleep:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: State(count: 0),","  reducer: reducer,","  environment: Environment(mainQueue: .immediate)",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With that small change we can drop the "},{"type":"codeVoice","code":"timeout"},{"type":"text","text":" arguments from the"},{"type":"text","text":" "},{"type":"codeVoice","code":"TestStore\/receive(_:timeout:_:file:line:)-88eyr"},{"type":"text","text":" invocations:"}]},{"type":"codeListing","syntax":"swift","code":["await store.receive(.timerTick) {","  $0.count = 1","}","await store.receive(.timerTick) {","  $0.count = 1","}","await store.receive(.timerTick) {","  $0.count = 2","}","await store.receive(.timerTick) {","  $0.count = 3","}","await store.receive(.timerTick) {","  $0.count = 4","}","await store.receive(.timerTick) {","  $0.count = 5","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"…and the test still passes, but now does so immediately."}]},{"anchor":"Designing-dependencies","level":2,"type":"heading","text":"Designing dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"overridingTitleInlineContent":[{"type":"text","text":"previous section"}],"isActive":true,"type":"reference","identifier":"#Testing-effects","overridingTitle":"previous section"},{"type":"text","text":" shows the basics of testing effects in features, but only"},{"type":"text","text":" "},{"type":"text","text":"for a simple time-based effect which was testable thanks to the tools that the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"Combine Schedulers"}],"isActive":true,"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/combine-schedulers","overridingTitle":"Combine Schedulers"},{"type":"text","text":" library provides."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, in general, the testability of a feature’s effects is correlated with how easy it is to"},{"type":"text","text":" "},{"type":"text","text":"control the dependencies your feature needs to do its job. If your feature needs to make network"},{"type":"text","text":" "},{"type":"text","text":"requests, access to a location manager, or generate random numbers, then all of those dependencies"},{"type":"text","text":" "},{"type":"text","text":"need to be designed in such a way that you can control them during tests so that you can make"},{"type":"text","text":" "},{"type":"text","text":"assertions on how your feature interacts with those clients."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are many ways to design controllable dependencies, and you can feel free to use any techniques"},{"type":"text","text":" "},{"type":"text","text":"you feel comfortable with, but we will quickly sketch one such pattern."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most dependencies can be modeled as an abstract interface to some endpoints that perform work"},{"type":"text","text":" "},{"type":"text","text":"and return some data. Protocols are a common way to model such interfaces, but simple structs with"},{"type":"text","text":" "},{"type":"text","text":"function properties can also work, and can reduce boilerplate."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you had a dependency that could make API requests to a server for fetching"},{"type":"text","text":" "},{"type":"text","text":"a fact about a number. This can be modeled as a simple struct with a single function property:"}]},{"type":"codeListing","syntax":"swift","code":["struct NumberFactClient {","  var fetch: (Int) async throws -> String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This defines the interface to fetching a number fact, and we can create a “live” implementation of"},{"type":"text","text":" "},{"type":"text","text":"the interface that makes an actual network request by constructing an instance, like so:"}]},{"type":"codeListing","syntax":"swift","code":["extension NumberFactClient {","  static let live = Self(","    fetch: { number in","      let (data, _) = try await URLSession.shared","        .data(from: URL(string: \"http:\/\/numbersapi.com\/\\(number)\/trivia\")!)","      return String(decoding: data, as: UTF8.self)","    }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This live implementation is appropriate to use when running the app in the simulator or on an actual"},{"type":"text","text":" "},{"type":"text","text":"device."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also create a “mock” implementation of the interface that doesn’t make a network request at"},{"type":"text","text":" "},{"type":"text","text":"all and instead immediately returns a predictable string:"}]},{"type":"codeListing","syntax":"swift","code":["extension NumberFactClient {","  static let mock = Self(","    fetch: { number in \"\\(number) is a good number.\" }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This mock implementation is appropriate to use in tests (and sometimes even previews) where you"},{"type":"text","text":" "},{"type":"text","text":"do not want to make live network requests since that leaves you open to the vagaries of the outside"},{"type":"text","text":" "},{"type":"text","text":"world that you cannot possibly predict."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if you had a simple feature that allows you to increment and decrement a counter,"},{"type":"text","text":" "},{"type":"text","text":"as well as fetch a fact for the current count, then you could test is roughly like so:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: State(),","  reducer: reducer,","  environment: Environment(numberFact: .mock)",")","","await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.factButtonTapped)","await store.receive(.factResponse(\"1 is a good number.\")) {","  $0.fact = \"1 is a good number.\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Such a test can run immediately without making a network request to the outside world, and it will"},{"type":"text","text":" "},{"type":"text","text":"pass deterministically 100% of the time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most, if not all, dependencies can be designed in this way, from API clients to location managers."},{"type":"text","text":" "},{"type":"text","text":"The Composable Architecture repo has "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples"},{"type":"text","text":" that demonstrate how to design"},{"type":"text","text":" "},{"type":"text","text":"clients for very complex dependencies, such as network requests, download managers, web sockets,"},{"type":"text","text":" "},{"type":"text","text":"speech recognition, and more."}]},{"anchor":"Unimplemented-dependencies","level":2,"type":"heading","text":"Unimplemented dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once you have designed your dependency in such a way that makes it easy to control, there is a"},{"type":"text","text":" "},{"type":"text","text":"particular implementation of the dependency that can increase the strength of your tests. In the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"previous section"}],"isActive":true,"type":"reference","identifier":"#Designing-dependencies","overridingTitle":"previous section"},{"type":"text","text":" we saw that we always want at least a “live”"},{"type":"text","text":" "},{"type":"text","text":"implementation for using in the production version of the app, and a “mock” implementation for using"},{"type":"text","text":" "},{"type":"text","text":"in tests, but there is another implementation that can be useful."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We call this the “unimplemented” implementation, which constructs an instance of the dependency"},{"type":"text","text":" "},{"type":"text","text":"client whose endpoints have all been stubbed to invoke "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" so that if the endpoint is ever"},{"type":"text","text":" "},{"type":"text","text":"used in a test it will trigger a test failure. This allows you to prove what parts of your"},{"type":"text","text":" "},{"type":"text","text":"dependency is actually used in a test."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Not every test needs to use every endpoint of every dependency your feature has access to. By"},{"type":"text","text":" "},{"type":"text","text":"providing the bare essentials of dependency endpoints that your test actually needs we can catch"},{"type":"text","text":" "},{"type":"text","text":"in the future when a certain execution path of the feature starts using a new dependency that we"},{"type":"text","text":" "},{"type":"text","text":"did not expect. This could either be due to a bug in the logic, or it could mean there is more logic"},{"type":"text","text":" "},{"type":"text","text":"that we need to assert on in the test."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose we were designing a client that could interface with a speech recognition API."},{"type":"text","text":" "},{"type":"text","text":"There would be an endpoint for requesting authorization to recognize speech on the device, an"},{"type":"text","text":" "},{"type":"text","text":"endpoint for starting a new speech recognition task, and an endpoint for finishing the task:"}]},{"type":"codeListing","syntax":"swift","code":["struct SpeechClient {","  var finishTask: () async -> Void","  var requestAuthorization: @Sendable () async -> SpeechAuthorizationStatus","  var startTask: (Request) async -> AsyncThrowingStream<SpeechRecognitionResult, Error>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can construct an instance of this client that stubs each endpoint as a function that simply"},{"type":"text","text":" "},{"type":"text","text":"calls "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" under the hood:"}]},{"type":"codeListing","syntax":"swift","code":["import XCTestDynamicOverlay","","extension SpeechClient {","  static let unimplemented = Self(","    finishTask: XCTUnimplemented(\"\\(Self.self).finishTask\"),","    requestAuthorization: XCTUnimplemented(\"\\(Self.self).requestAuthorization\"),","    startTask: XCTUnimplemented(\"\\(Self.self).recognitionTask\")","  )","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In general, "},{"type":"codeVoice","code":"XCTest"},{"type":"text","text":" APIs cannot be used in code that is run in the simulator or on devices."},{"type":"text","text":" "},{"type":"text","text":"To get around this we make use of our "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay"},{"type":"text","text":" library,"},{"type":"text","text":" "},{"type":"text","text":"which dynamically loads "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" to be available in all execution environments, not only tests."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then in tests we start the store’s environment with the unimplemented client, and override the bare"},{"type":"text","text":" "},{"type":"text","text":"essentials of endpoints we expect to be called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if we were testing the flow in the feature where the user denies speech recognition"},{"type":"text","text":" "},{"type":"text","text":"access, then we would not expect the "},{"type":"codeVoice","code":"startTask"},{"type":"text","text":" or "},{"type":"codeVoice","code":"finishTask"},{"type":"text","text":" endpoints to ever be called. That"},{"type":"text","text":" "},{"type":"text","text":"would probably be a logical error, after all when the user denies permission those endpoints can’t"},{"type":"text","text":" "},{"type":"text","text":"do anything useful."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can prove that this is the case by using the "},{"type":"codeVoice","code":".unimplemented"},{"type":"text","text":" speech client in the test, and then"},{"type":"text","text":" "},{"type":"text","text":"overriding only the "},{"type":"codeVoice","code":"requestAuthorization"},{"type":"text","text":" endpoint with an actual implementation:"}]},{"type":"codeListing","syntax":"swift","code":["func testDeniedAuthorization() async {","  let store = TestStore(","    initialState: State(),","    reducer: reducer,","    environment: Environment(speech: .unimplemented)","  )","","  store.environment.speech.requestAuthorization = { .denied }","","  …","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can make your tests much stronger by starting all dependencies in an “unimplemented” state, and"},{"type":"text","text":" "},{"type":"text","text":"then only implementing the bare essentials of endpoints that your feature needs for the particular"},{"type":"text","text":" "},{"type":"text","text":"flow you are testing. Then in the future, if your feature starts using new dependency endpoints you"},{"type":"text","text":" "},{"type":"text","text":"will be instantly notified in tests and can figure out if that is expected or if a bug has been"},{"type":"text","text":" "},{"type":"text","text":"introduced."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/testing"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Testing","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingReadyForSwiftConcurrency","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance"],"generated":true}],"references":{"#Testing-effects":{"title":"Testing effects","titleInlineContent":[{"type":"text","text":"Testing effects"}],"type":"link","identifier":"#Testing-effects","url":"#Testing-effects"},"http://github.com/pointfreeco/xctest-dynamic-overlay":{"title":"XCTest Dynamic Overlay","titleInlineContent":[{"type":"text","text":"XCTest Dynamic Overlay"}],"type":"link","identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay","url":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"role":"symbol","title":"Reducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"abstract":[{"type":"text","text":"A reducer describes how to evolve the current state of an application to the next state, given"},{"type":"text","text":" "},{"type":"text","text":"an action, and describes what "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":"s should be executed later by the store, if any."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"url":"\/documentation\/composablearchitecture\/reducer"},"#Testing-state-changes":{"title":"Testing state changes","titleInlineContent":[{"type":"text","text":"Testing state changes"}],"type":"link","identifier":"#Testing-state-changes","url":"#Testing-state-changes"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"role":"article","title":"Getting started","abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingstarted"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Store":{"role":"symbol","title":"Store","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"abstract":[{"type":"text","text":"A store represents the runtime that powers the application. It is the object that you will pass"},{"type":"text","text":" "},{"type":"text","text":"around to views that need to interact with the application."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/composablearchitecture\/store"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/TestStore/send(_:_:file:line:)-7vwv9":{"conformance":{"constraints":[{"type":"codeVoice","code":"LocalState"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"send(_:_:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"send"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"LocalAction","preciseIdentifier":"s:22ComposableArchitecture9TestStoreCAASQR_rlE11LocalActionq1_mfp"},{"kind":"text","text":", (("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"LocalState","preciseIdentifier":"s:22ComposableArchitecture9TestStoreCAASQR_rlE10LocalStateq_mfp"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"TestStoreTask","preciseIdentifier":"s:22ComposableArchitecture13TestStoreTaskV"}],"abstract":[{"type":"text","text":"Sends an action to the store and asserts when state changes."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:_:file:line:)-7vwv9","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/send(_:_:file:line:)-7vwv9"},"https://github.com/pointfreeco/swift-composable-architecture/tree/main/Examples":{"title":"many examples","titleInlineContent":[{"type":"text","text":"many examples"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples","url":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/TestStore/state":{"role":"symbol","title":"state","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"state"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"State","preciseIdentifier":"s:22ComposableArchitecture9TestStoreC5Statexmfp"}],"abstract":[{"type":"text","text":"The current state."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/state"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"role":"symbol","title":"Effect","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"abstract":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":" type encapsulates a unit of work that can be run in the outside world, and can"},{"type":"text","text":" "},{"type":"text","text":"feed data back to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"type":"text","text":". It is the perfect place to do side effects, such as network"},{"type":"text","text":" "},{"type":"text","text":"requests, saving\/loading from disk, creating timers, interacting with dependencies, and more."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Effect"}],"url":"\/documentation\/composablearchitecture\/effect"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"role":"symbol","title":"TestStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStore"}],"abstract":[{"type":"text","text":"A testable runtime for a reducer."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TestStore"}],"url":"\/documentation\/composablearchitecture\/teststore"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Effect/run(priority:operation:catch:file:fileID:line:)":{"conformance":{"constraints":[{"type":"codeVoice","code":"Failure"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Never"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"run(priority:operation:catch:file:fileID:line:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"run"},{"kind":"text","text":"("},{"kind":"externalParam","text":"priority"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"TaskPriority","preciseIdentifier":"s:ScP"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"Send","preciseIdentifier":"s:22ComposableArchitecture4SendV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Output","preciseIdentifier":"s:22ComposableArchitecture6EffectVAAs5NeverORs_rlE6Outputxmfp"},{"kind":"text","text":">) "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":", "},{"kind":"externalParam","text":"catch"},{"kind":"text","text":": (("},{"kind":"typeIdentifier","text":"Error","preciseIdentifier":"s:s5ErrorP"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Send","preciseIdentifier":"s:22ComposableArchitecture4SendV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Output","preciseIdentifier":"s:22ComposableArchitecture6EffectVAAs5NeverORs_rlE6Outputxmfp"},{"kind":"text","text":">) "},{"kind":"keyword","text":"async"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"fileID"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Effect","preciseIdentifier":"s:22ComposableArchitecture6EffectV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Failure"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Wraps an asynchronous unit of work that can emit any number of times in an effect."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect\/run(priority:operation:catch:file:fileID:line:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/effect\/run(priority:operation:catch:file:fileid:line:)"},"http://github.com/pointfreeco/combine-schedulers":{"title":"Combine Schedulers","titleInlineContent":[{"type":"text","text":"Combine Schedulers"}],"type":"link","identifier":"http:\/\/github.com\/pointfreeco\/combine-schedulers","url":"http:\/\/github.com\/pointfreeco\/combine-schedulers"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"role":"article","title":"Performance","abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/performance"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/GettingReadyForSwiftConcurrency":{"role":"article","title":"Getting ready for Swift concurrency","abstract":[{"type":"text","text":"Learn how to write safe, concurrent effects using Swift’s structured concurrency."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingReadyForSwiftConcurrency","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingreadyforswiftconcurrency"},"#Designing-dependencies":{"title":"Designing dependencies","titleInlineContent":[{"type":"text","text":"Designing dependencies"}],"type":"link","identifier":"#Designing-dependencies","url":"#Designing-dependencies"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"}}}