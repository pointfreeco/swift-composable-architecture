{"seeAlsoSections":[{"title":"Testing","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ActorIsolated"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"final"},{"kind":"text","text":" "},{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStore"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"State"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Action"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"ScopedState"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"ScopedAction"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Environment"},{"kind":"text","text":">"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This object aids in writing expressive and exhaustive tests for features built in the"},{"type":"text","text":" "},{"type":"text","text":"Composable Architecture. It allows you to send a sequence of actions to the store, and each"},{"type":"text","text":" "},{"type":"text","text":"step of the way you must assert exactly how state changed, and how effect emissions were fed"},{"type":"text","text":" "},{"type":"text","text":"back into the system."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See the dedicated "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"},{"type":"text","text":" article for detailed information on testing."}]},{"anchor":"Exhaustive-testing","level":2,"type":"heading","text":"Exhaustive testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" requires you to exhaustively prove how your feature evolves from"},{"type":"text","text":" "},{"type":"text","text":"sending use actions and receiving actions from effects. There are multiple ways the test store"},{"type":"text","text":" "},{"type":"text","text":"forces you to do this:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"After each action is sent you must describe precisely how the state changed from before"},{"type":"text","text":" "},{"type":"text","text":"the action was sent to after it was sent."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If even the smallest piece of data differs the test will fail. This guarantees that you"},{"type":"text","text":" "},{"type":"text","text":"are proving you know precisely how the state of the system changes."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Sending an action can sometimes cause an effect to be executed, and if that effect sends"},{"type":"text","text":" "},{"type":"text","text":"an action back into the system, you "},{"type":"strong","inlineContent":[{"type":"text","text":"must"}]},{"type":"text","text":" explicitly assert that you expect to receive"},{"type":"text","text":" "},{"type":"text","text":"that action from the effect, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" you must assert how state changed as a result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you try to send another action before you have handled all effect actions, the"},{"type":"text","text":" "},{"type":"text","text":"test will fail. This guarantees that you do not accidentally forget about an effect"},{"type":"text","text":" "},{"type":"text","text":"action, and that the sequence of steps you are describing will mimic how the application"},{"type":"text","text":" "},{"type":"text","text":"behaves in reality."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"All effects must complete by the time the test case has finished running, and all effect"},{"type":"text","text":" "},{"type":"text","text":"actions must be asserted on."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If at the end of the assertion there is still an in-flight effect running or an unreceived"},{"type":"text","text":" "},{"type":"text","text":"action, the assertion will fail. This helps exhaustively prove that you know what effects"},{"type":"text","text":" "},{"type":"text","text":"are in flight and forces you to prove that effects will not cause any future changes to"},{"type":"text","text":" "},{"type":"text","text":"your state."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, given a simple counter reducer:"}]},{"type":"codeListing","syntax":"swift","code":["struct Counter: ReducerProtocol {","  struct State: Equatable {","    var count = 0","  }","","  enum Action {","    case decrementButtonTapped","    case incrementButtonTapped","  }","","  func reduce(","    into state: inout State, action: Action","  ) -> EffectTask<Action> {","    switch action {","    case .decrementButtonTapped:","      state.count -= 1","      return .none","","    case .incrementButtonTapped:","      state.count += 1","      return .none","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One can assert against its behavior over time:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","class CounterTests: XCTestCase {","  func testCounter() async {","    let store = TestStore(","      \/\/ Given: a counter state of 0","      initialState: Counter.State(count: 0),","      reducer: Counter()","    )","","    \/\/ When: the increment button is tapped","    await store.send(.incrementButtonTapped) {","      \/\/ Then: the count should be 1","      $0.count = 1","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that in the trailing closure of "},{"type":"codeVoice","code":".send(.incrementButtonTapped)"},{"type":"text","text":" we are given a single"},{"type":"text","text":" "},{"type":"text","text":"mutable value of the state before the action was sent, and it is our job to mutate the value"},{"type":"text","text":" "},{"type":"text","text":"to match the state after the action was sent. In this case the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" field changes to "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the change made in the closure does not reflect reality, you will get a test failure with"},{"type":"text","text":" "},{"type":"text","text":"a nicely formatted failure message letting you know exactly what went wrong:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  $0.count = 42","}"]},{"type":"codeListing","syntax":null,"code":["ðŸ›‘ A state change does not match expectation: â€¦","","     TestStoreFailureTests.State(","    âˆ’   count: 42","    +   count: 1","     )","","(Expected: âˆ’, Actual: +)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a more complex example, consider the following bare-bones search feature that uses a"},{"type":"text","text":" "},{"type":"text","text":"clock and cancel token to debounce requests:"}]},{"type":"codeListing","syntax":"swift","code":["struct Search: ReducerProtocol {","  struct State: Equatable {","    var query = \"\"","    var results: [String] = []","  }","","  enum Action: Equatable {","    case queryChanged(String)","    case searchResponse(TaskResult<[String]>)","  }","","  @Dependency(\\.apiClient) var apiClient","  @Dependency(\\.continuousClock) var clock","  private enum SearchID {}","","  func reduce(","    into state: inout State, action: Action","  ) -> EffectTask<Action> {","    switch action {","    case let .queryChanged(query):","      state.query = query","      return .run { send in","        try await self.clock.sleep(for: 0.5)","","        guard let results = try? await self.apiClient.search(query)","        else { return }","","        await send(.response(results))","      }","      .cancellable(id: SearchID.self)","","    case let .searchResponse(.success(results)):","      state.results = results","      return .none","","    case .searchResponse(.failure):","      \/\/ Do error handling here.","      return .none","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It can be fully tested by overriding the "},{"type":"codeVoice","code":"apiClient"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continuousClock"},{"type":"text","text":" dependencies with"},{"type":"text","text":" "},{"type":"text","text":"values that are fully controlled and deterministic:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: Search.State(),","  reducer: Search()",")","","\/\/ Simulate a search response with one item","store.dependencies.apiClient.search = { _ in","  [\"Composable Architecture\"]","}","","\/\/ Create a test clock to control the timing of effects","let clock = TestClock()","store.dependencies.continuousClock = clock","","\/\/ Change the query","await store.send(.searchFieldChanged(\"c\") {","  \/\/ Assert that state updates accordingly","  $0.query = \"c\"","}","","\/\/ Advance the clock by enough to get past the debounce","await clock.advance(by: 0.5)","","\/\/ Assert that the expected response is received","await store.receive(.searchResponse(.success([\"Composable Architecture\"]))) {","  $0.results = [\"Composable Architecture\"]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This test is proving that when the search query changes some search responses are delivered and"},{"type":"text","text":" "},{"type":"text","text":"state updates accordingly."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we did not assert that the "},{"type":"codeVoice","code":"searchResponse"},{"type":"text","text":" action was received, we would get the following"},{"type":"text","text":" "},{"type":"text","text":"test failure:"}]},{"type":"codeListing","syntax":null,"code":["ðŸ›‘ The store received 1 unexpected action after this one: â€¦","","    Unhandled actions: [","      [0]: Search.Action.searchResponse","    ]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This helpfully lets us know that we have no asserted on everything that happened in the feature,"},{"type":"text","text":" "},{"type":"text","text":"which could be hiding a bug from us."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or if we had sent another action before handling the effectâ€™s action we would have also gotten"},{"type":"text","text":" "},{"type":"text","text":"a test failure:"}]},{"type":"codeListing","syntax":null,"code":["ðŸ›‘ Must handle 1 received action before sending an action: â€¦","","    Unhandled actions: [","      [0]: Search.Action.searchResponse","    ]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of these types of failures help you prove that you know exactly how your feature evolves"},{"type":"text","text":" "},{"type":"text","text":"as actions are sent into the system. If the library did not produce a test failure in these"},{"type":"text","text":" "},{"type":"text","text":"situations it could be hiding subtle bugs in your code. For example, when the user clears the"},{"type":"text","text":" "},{"type":"text","text":"search query you probably expect that the results are cleared and no search request is executed"},{"type":"text","text":" "},{"type":"text","text":"since there is no query. This can be done like so:"}]},{"type":"codeListing","syntax":"swift","code":["await store.send(.queryChanged(\"\")) {","  $0.query = \"\"","  $0.results = []","}","","\/\/ No need to perform `store.receive` since we do not expect a search","\/\/ effect to execute."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But, if in the future a bug is introduced causing a search request to be executed even when the"},{"type":"text","text":" "},{"type":"text","text":"query is empty, you will get a test failure because a new effect is being created that is"},{"type":"text","text":" "},{"type":"text","text":"not being asserted on. This is the power of exhaustive testing."}]},{"anchor":"Non-exhaustive-testing","level":2,"type":"heading","text":"Non-exhaustive testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"While exhaustive testing can be powerful, it can also be a nuisance, especially when testing"},{"type":"text","text":" "},{"type":"text","text":"how many features integrate together. This is why sometimes you may want to selectively test"},{"type":"text","text":" "},{"type":"text","text":"in a non-exhaustive style."}]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The concept of â€œnon-exhaustive test storeâ€ was first introduced by"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.merowing.info"},{"type":"text","text":" in a "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/vimeo.com\/751173570"},{"type":"text","text":", and then later became integrated into the"},{"type":"text","text":" "},{"type":"text","text":"core library."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test stores are exhaustive by default, which means you must assert on every state change, and"},{"type":"text","text":" "},{"type":"text","text":"how ever effect feeds data back into the system, and you must make sure that all effects"},{"type":"text","text":" "},{"type":"text","text":"complete before the test is finished. To turn off exhaustivity you can set "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity"},{"type":"text","text":" "},{"type":"text","text":"to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off"},{"type":"text","text":". When that is done the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":"â€™s behavior changes:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The trailing closures of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd"},{"type":"text","text":" no longer need to assert on all state changes."},{"type":"text","text":" "},{"type":"text","text":"They can assert on any subset of changes, and only if they make an incorrect mutation will a"},{"type":"text","text":" "},{"type":"text","text":"test failure be reported."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd"},{"type":"text","text":" "},{"type":"text","text":"methods are allowed to be called even when actions have been received from effects that have"},{"type":"text","text":" "},{"type":"text","text":"not been asserted on yet. Any pending actions will be cleared."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tests are allowed to finish with unasserted, received actions and in-flight effects. No test"},{"type":"text","text":" "},{"type":"text","text":"failures will be reported."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-exhaustive stores can be configured to report skipped assertions by configuring"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)"},{"type":"text","text":". When set to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" the test store will have the"},{"type":"text","text":" "},{"type":"text","text":"added behavior that any unasserted change causes a grey, informational box to appear next to"},{"type":"text","text":" "},{"type":"text","text":"each assertion detailing the changes that were not asserted against. This allows you to see what"},{"type":"text","text":" "},{"type":"text","text":"information you are choosing to ignore without causing a test failure. It can be useful in"},{"type":"text","text":" "},{"type":"text","text":"tracking down bugs that happen in production but that arenâ€™t currently detected in tests."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This style of testing is most useful for testing the integration of multiple features where you"},{"type":"text","text":" "},{"type":"text","text":"want to focus on just a certain slice of the behavior. Exhaustive testing can still be important"},{"type":"text","text":" "},{"type":"text","text":"to use for leaf node features, where you truly do want to assert on everything happening inside"},{"type":"text","text":" "},{"type":"text","text":"the feature."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a tab-based application where the 3rd tab is a login screen. The"},{"type":"text","text":" "},{"type":"text","text":"user can fill in some data on the screen, then tap the â€œSubmitâ€ button, and then a series of"},{"type":"text","text":" "},{"type":"text","text":"events happens to  log the user in. Once the user is logged in, the 3rd tab switches from a"},{"type":"text","text":" "},{"type":"text","text":"login screen to a profile screen, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" the selected tab switches to the first tab, which is an"},{"type":"text","text":" "},{"type":"text","text":"activity screen."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When writing tests for the login feature we will want to do that in the exhaustive style so that"},{"type":"text","text":" "},{"type":"text","text":"we can prove exactly how the feature would behave in production. But, suppose we wanted to write"},{"type":"text","text":" "},{"type":"text","text":"an integration test that proves after the user taps the â€œLoginâ€ button that ultimately the"},{"type":"text","text":" "},{"type":"text","text":"selected tab switches to the first tab."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to test such a complex flow we must test the integration of multiple features, which"},{"type":"text","text":" "},{"type":"text","text":"means dealing with complex, nested state and effects. We can emulate this flow in a test by"},{"type":"text","text":" "},{"type":"text","text":"sending actions that mimic the user logging in, and then eventually assert that the selected"},{"type":"text","text":" "},{"type":"text","text":"tab switched to activity:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: App.State(),","  reducer: App()",")","","\/\/ 1ï¸âƒ£ Emulate user tapping on submit button.","await store.send(.login(.submitButtonTapped)) {","  \/\/ 2ï¸âƒ£ Assert how all state changes in the login feature","  $0.login?.isLoading = true","  â€¦","}","","\/\/ 3ï¸âƒ£ Login feature performs API request to login, and","\/\/    sends response back into system.","await store.receive(.login(.loginResponse(.success))) {","\/\/ 4ï¸âƒ£ Assert how all state changes in the login feature","  $0.login?.isLoading = false","  â€¦","}","","\/\/ 5ï¸âƒ£ Login feature sends a delegate action to let parent","\/\/    feature know it has successfully logged in.","await store.receive(.login(.delegate(.didLogin))) {","\/\/ 6ï¸âƒ£ Assert how all of app state changes due to that action.","  $0.authenticatedTab = .loggedIn(","    Profile.State(...)","  )","  â€¦","  \/\/ 7ï¸âƒ£ *Finally* assert that the selected tab switches to activity.","  $0.selectedTab = .activity","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Doing this with exhaustive testing is verbose, and there are a few problems with this:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We need to be intimately knowledgeable in how the login feature works so that we can assert"},{"type":"text","text":" "},{"type":"text","text":"on how its state changes and how its effects feed data back into the system."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the login feature were to change its logic we may get test failures here even though the"},{"type":"text","text":" "},{"type":"text","text":"logic we are actually trying to test doesnâ€™t really care about those changes."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This test is very long, and so if there are other similar but slightly different flows we"},{"type":"text","text":" "},{"type":"text","text":"want to test we will be tempted to copy-and-paste the whole thing, leading to lots of"},{"type":"text","text":" "},{"type":"text","text":"duplicated, fragile tests."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-exhaustive testing allows us to test the high-level flow that we are concerned with, that of"},{"type":"text","text":" "},{"type":"text","text":"login causing the selected tab to switch to activity, without having to worry about what is"},{"type":"text","text":" "},{"type":"text","text":"happening inside the login feature. To do this, we can turn off "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity"},{"type":"text","text":" in"},{"type":"text","text":" "},{"type":"text","text":"the test store, and then just assert on what we are interested in:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: App.State(),","  reducer: App()",")","store.exhaustivity = .off \/\/ â¬…ï¸","","await store.send(.login(.submitButtonTapped))","await store.receive(.login(.delegate(.didLogin))) {","  $0.selectedTab = .activity","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In particular, we did not assert on how the loginâ€™s state changed or how the loginâ€™s effects fed"},{"type":"text","text":" "},{"type":"text","text":"data back into the system. We just assert that when the â€œSubmitâ€ button is tapped that"},{"type":"text","text":" "},{"type":"text","text":"eventually we get the "},{"type":"codeVoice","code":"didLogin"},{"type":"text","text":" delegate action and that causes the selected tab to flip to"},{"type":"text","text":" "},{"type":"text","text":"activity. Now the login feature is free to make any change it wants to make without affecting"},{"type":"text","text":" "},{"type":"text","text":"this integration test."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off"},{"type":"text","text":" for "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity"},{"type":"text","text":" causes all un-asserted changes to"},{"type":"text","text":" "},{"type":"text","text":"pass without any notification. If you would like to see what test failures are being suppressed"},{"type":"text","text":" "},{"type":"text","text":"without actually causing a failure, you can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: App.State(),","  reducer: App()",")","store.exhaustivity = .off(showSkippedAssertions: true) \/\/ â¬…ï¸","","await store.send(.login(.submitButtonTapped))","await store.receive(.login(.delegate(.didLogin))) {","  $0.selectedTab = .profile","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When this is run you will get grey, informational boxes on each assertion where some change"},{"type":"text","text":" "},{"type":"text","text":"wasnâ€™t fully asserted on:"}]},{"type":"codeListing","syntax":null,"code":["â—½ï¸ A state change does not match expectation: â€¦","","   â€‡ App.State(","   â€‡   authenticatedTab: .loggedOut(","         Login.State(","   âˆ’       isLoading: false","   +       isLoading: true,","           â€¦","         )","       )","   â€‡ )","","   (Expected: âˆ’, Actual: +)","","â—½ï¸ Skipped receiving .login(.loginResponse(.success))","","â—½ï¸ A state change does not match expectation: â€¦","","   â€‡ App.State(","   âˆ’   authenticatedTab: .loggedOut(â€¦)","   +   authenticatedTab: .loggedIn(","   +     Profile.State(â€¦)","   +   ),","       â€¦","   â€‡ )","","   (Expected: âˆ’, Actual: +)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The test still passes, and none of these notifications are test failures. They just let you know"},{"type":"text","text":" "},{"type":"text","text":"what things you are not explicitly asserting against, and can be useful to see when tracking"},{"type":"text","text":" "},{"type":"text","text":"down bugs that happen in production but that arenâ€™t currently detected in tests."}]}]}],"variants":[{"paths":["\/documentation\/composablearchitecture\/teststore"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A testable runtime for a reducer."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStore"}],"title":"TestStore","roleHeading":"Class","role":"symbol","symbolKind":"class","externalID":"s:22ComposableArchitecture9TestStoreC","modules":[{"name":"ComposableArchitecture"}],"navigatorTitle":[{"kind":"identifier","text":"TestStore"}]},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"topicSections":[{"title":"Configuring a test store","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/dependencies","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/timeout"]},{"title":"Testing a reducer","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-4e4m0","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-3myco","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/finish(timeout:file:line:)","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStoreTask"]},{"title":"Methods for skipping actions and effects","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/skipReceivedActions(strict:file:line:)-a4ri","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/skipInFlightEffects(strict:file:line:)-5hbsk"]},{"title":"Accessing state","abstract":[{"type":"text","text":"While the most common way of interacting with a test storeâ€™s state is via its "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd"},{"type":"text","text":" methods, you may also access it directly throughout a test."}],"identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state"]},{"title":"Scoping test stores","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/scope(state:action:)","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/scope(state:)"]},{"title":"Deprecations","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStoreDeprecations"]},{"title":"Initializers","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/init(initialState:reducer:prepareDependencies:file:line:)"]}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/receive(_:timeout:assert:file:line:)-3myco":{"conformance":{"constraints":[{"type":"codeVoice","code":"Action"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ScopedState"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"receive(_:timeout:assert:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"receive"},{"kind":"text","text":"(("},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":", "},{"kind":"externalParam","text":"timeout"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt64","preciseIdentifier":"s:s6UInt64V"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"assert"},{"kind":"text","text":": (("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Asserts a matching action was received from an effect and asserts how the state changes."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-3myco","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/receive(_:timeout:assert:file:line:)-3myco"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/send(_:assert:file:line:)-1ax61":{"role":"symbol","title":"send(_:assert:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"send"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"ScopedAction"},{"kind":"text","text":", "},{"kind":"externalParam","text":"assert"},{"kind":"text","text":": (("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"TestStoreTask","preciseIdentifier":"s:22ComposableArchitecture13TestStoreTaskV"}],"abstract":[{"type":"text","text":"Sends an action to the store and asserts when state changes."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/send(_:assert:file:line:)-1ax61"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Exhaustivity/off(showSkippedAssertions:)":{"role":"symbol","title":"Exhaustivity.off(showSkippedAssertions:)","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"off"},{"kind":"text","text":"("},{"kind":"externalParam","text":"showSkippedAssertions"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Non-exhaustive assertions."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/exhaustivity\/off(showskippedassertions:)"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/scope(state:)":{"role":"symbol","title":"scope(state:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"scope"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"S"},{"kind":"text","text":">("},{"kind":"externalParam","text":"state"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"S"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"TestStore","preciseIdentifier":"s:22ComposableArchitecture9TestStoreC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"S"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ScopedAction"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Environment"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Scopes a store to assert against scoped state."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/scope(state:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/scope(state:)"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/exhaustivity":{"role":"symbol","title":"exhaustivity","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"exhaustivity"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Exhaustivity","preciseIdentifier":"s:22ComposableArchitecture12ExhaustivityO"}],"abstract":[{"type":"text","text":"The current exhaustivity level of the test store."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/exhaustivity"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"role":"symbol","title":"TestStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStore"}],"abstract":[{"type":"text","text":"A testable runtime for a reducer."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TestStore"}],"url":"\/documentation\/composablearchitecture\/teststore"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/state":{"role":"symbol","title":"state","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"state"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"State"}],"abstract":[{"type":"text","text":"The current state of the test store."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/state"},"https://www.merowing.info/exhaustive-testing-in-tca/":{"title":"blog post","titleInlineContent":[{"type":"text","text":"blog post"}],"type":"link","identifier":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/","url":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/dependencies":{"role":"symbol","title":"dependencies","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"dependencies"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"DependencyValues","preciseIdentifier":"s:12Dependencies16DependencyValuesV"}],"abstract":[{"type":"text","text":"The current dependencies of the test store."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/dependencies","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/dependencies"},"https://www.merowing.info":{"title":"Krzysztof ZabÅ‚ocki","titleInlineContent":[{"type":"text","text":"Krzysztof ZabÅ‚ocki"}],"type":"link","identifier":"https:\/\/www.merowing.info","url":"https:\/\/www.merowing.info"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStoreTask":{"role":"symbol","title":"TestStoreTask","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStoreTask"}],"abstract":[{"type":"text","text":"The type returned from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61"},{"type":"text","text":" that represents the"},{"type":"text","text":" "},{"type":"text","text":"lifecycle of the effect started from sending an action."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStoreTask","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TestStoreTask"}],"url":"\/documentation\/composablearchitecture\/teststoretask"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/init(initialState:reducer:prepareDependencies:file:line:)":{"role":"symbol","title":"init(initialState:reducer:prepareDependencies:file:line:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Reducer"},{"kind":"text","text":">("},{"kind":"externalParam","text":"initialState"},{"kind":"text","text":": () -> "},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":", "},{"kind":"externalParam","text":"reducer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Reducer"},{"kind":"text","text":", "},{"kind":"externalParam","text":"prepareDependencies"},{"kind":"text","text":": ("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"DependencyValues","preciseIdentifier":"s:12Dependencies16DependencyValuesV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":", "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Creates a test store with an initial state and a reducer powering itâ€™s runtime."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/init(initialState:reducer:prepareDependencies:file:line:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/init(initialstate:reducer:preparedependencies:file:line:)"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/scope(state:action:)":{"role":"symbol","title":"scope(state:action:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"scope"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"S"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"A"},{"kind":"text","text":">("},{"kind":"externalParam","text":"state"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"S"},{"kind":"text","text":", "},{"kind":"externalParam","text":"action"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"A"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"ScopedAction"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"TestStore","preciseIdentifier":"s:22ComposableArchitecture9TestStoreC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"S"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"A"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Environment"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Scopes a store to assert against scoped state and actions."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/scope(state:action:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/scope(state:action:)"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/skipReceivedActions(strict:file:line:)-a4ri":{"role":"symbol","title":"skipReceivedActions(strict:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"skipReceivedActions"},{"kind":"text","text":"("},{"kind":"externalParam","text":"strict"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":", "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Clears the queue of received actions from effects."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/skipReceivedActions(strict:file:line:)-a4ri","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/skipreceivedactions(strict:file:line:)-a4ri"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStoreDeprecations":{"role":"collectionGroup","title":"Deprecations","abstract":[{"type":"text","text":"Review unsupported test store APIs and their replacements."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStoreDeprecations","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/teststoredeprecations"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/testing"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ActorIsolated":{"role":"symbol","title":"ActorIsolated","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActorIsolated"}],"abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value to an actor."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ActorIsolated","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActorIsolated"}],"url":"\/documentation\/composablearchitecture\/actorisolated"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/skipInFlightEffects(strict:file:line:)-5hbsk":{"role":"symbol","title":"skipInFlightEffects(strict:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"skipInFlightEffects"},{"kind":"text","text":"("},{"kind":"externalParam","text":"strict"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":", "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Cancels any currently in-flight effects."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/skipInFlightEffects(strict:file:line:)-5hbsk","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/skipinflighteffects(strict:file:line:)-5hbsk"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/receive(_:timeout:assert:file:line:)-1rwdd":{"conformance":{"constraints":[{"type":"codeVoice","code":"Action"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ScopedState"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"receive(_:timeout:assert:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"receive"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"kind":"externalParam","text":"timeout"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt64","preciseIdentifier":"s:s6UInt64V"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"assert"},{"kind":"text","text":": (("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Asserts an action was received from an effect and asserts how the state changes."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/receive(_:timeout:assert:file:line:)-1rwdd"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/receive(_:timeout:assert:file:line:)-4e4m0":{"conformance":{"constraints":[{"type":"codeVoice","code":"Action"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ScopedState"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"receive(_:timeout:assert:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"receive"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"CasePath","preciseIdentifier":"s:9CasePaths0A4PathV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":">, "},{"kind":"externalParam","text":"timeout"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt64","preciseIdentifier":"s:s6UInt64V"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"assert"},{"kind":"text","text":": (("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Asserts an action was received matching a case path and asserts how the state changes."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-4e4m0","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/receive(_:timeout:assert:file:line:)-4e4m0"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/timeout":{"role":"symbol","title":"timeout","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"timeout"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt64","preciseIdentifier":"s:s6UInt64V"}],"abstract":[{"type":"text","text":"The default timeout used in all methods that take an optional timeout."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/timeout","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/timeout"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Exhaustivity/off":{"role":"symbol","title":"off","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"off"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Exhaustivity","preciseIdentifier":"s:22ComposableArchitecture12ExhaustivityO"}],"abstract":[{"type":"text","text":"Non-exhaustive assertions."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/exhaustivity\/off"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/finish(timeout:file:line:)":{"role":"symbol","title":"finish(timeout:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"finish"},{"kind":"text","text":"("},{"kind":"externalParam","text":"timeout"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt64","preciseIdentifier":"s:s6UInt64V"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Suspends until all in-flight effects have finished, or until it times out."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/finish(timeout:file:line:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/teststore\/finish(timeout:file:line:)"},"https://vimeo.com/751173570":{"title":"conference talk","titleInlineContent":[{"type":"text","text":"conference talk"}],"type":"link","identifier":"https:\/\/vimeo.com\/751173570","url":"https:\/\/vimeo.com\/751173570"}}}