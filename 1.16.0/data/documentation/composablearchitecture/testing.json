{"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"sections":[],"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"primaryContentSections":[{"content":[{"type":"heading","anchor":"overview","level":2,"text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The testability of features built in the Composable Architecture is the #1 priority of the library."},{"text":" ","type":"text"},{"text":"It should be possible to test not only how state changes when actions are sent into the store, but","type":"text"},{"type":"text","text":" "},{"type":"text","text":"also how effects are executed and feed data back into the system."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Testing-state-changes"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"#Testing-effects","type":"reference","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"#Non-exhaustive-testing","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"#Testing-gotchas","isActive":true}],"type":"paragraph"}]}]},{"text":"Testing state changes","type":"heading","level":2,"anchor":"Testing-state-changes"},{"type":"paragraph","inlineContent":[{"text":"State changes are by far the simplest thing to test in features built with the library. A","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true},{"text":"’s first responsibility is to mutate the current state based on the action received into","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the system. To test this we can technically run a piece of mutable state through the reducer and"},{"type":"text","text":" "},{"text":"then assert on how it changed after, like this:","type":"text"}]},{"code":["@Reducer","struct Feature {","  @ObservableState","  struct State: Equatable {","    var count = 0","  }","  enum Action {","    case incrementButtonTapped","    case decrementButtonTapped","  }","  var body: some Reduce<State, Action> {","    Reduce { state, action in","      switch action {","      case .incrementButtonTapped:","        state.count += 1","        return .none","      case .decrementButtonTapped:","        state.count -= 1","        return .none","      }","    }","  }","}","","@Test","func basics() {","  let feature = Feature()","  var currentState = Feature.State(count: 0)","  _ = feature.reduce(into: &currentState, action: .incrementButtonTapped)","  #expect(currentState == State(count: 1))","","  _ = feature.reduce(into: &currentState, action: .decrementButtonTapped)","  #expect(currentState == State(count: 0))","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will technically work, but it’s a lot boilerplate for something that should be quite simple."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a tool specifically designed to make testing like this much simpler and more"},{"text":" ","type":"text"},{"type":"text","text":"concise. It’s called "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","isActive":true,"type":"reference"},{"type":"text","text":", and it is constructed similarly to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"type":"text","text":" by providing the"},{"text":" ","type":"text"},{"text":"initial state of the feature and the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true},{"text":" that runs the feature’s logic:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["import Testing","","@MainActor","struct CounterTests {","  @Test","  func basics() async {","    let store = TestStore(initialState: Feature.State(count: 0)) {","      Feature()","    }","  }","}"]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tests that use "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" should be marked as "},{"code":"async","type":"codeVoice"},{"text":" since most assertion helpers on","type":"text"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"reference","isActive":true},{"type":"text","text":" can suspend. And while tests do not "},{"inlineContent":[{"text":"require","type":"text"}],"type":"emphasis"},{"type":"text","text":" the main actor, "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","isActive":true},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"is","type":"text"}]},{"text":" ","type":"text"},{"text":"main actor-isolated, and so we recommend annotating your tests and suites with ","type":"text"},{"type":"codeVoice","code":"@MainActor"},{"type":"text","text":"."}]}],"type":"aside","name":"Tip","style":"tip"},{"type":"paragraph","inlineContent":[{"text":"Test stores have a ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl"},{"text":" method, but it behaves differently from","type":"text"},{"type":"text","text":" "},{"text":"stores and view stores. You provide an action to send into the system, but then you must also","type":"text"},{"type":"text","text":" "},{"text":"provide a trailing closure to describe how the state of the feature changed after sending the","type":"text"},{"text":" ","type":"text"},{"text":"action:","type":"text"}]},{"syntax":"swift","code":["await store.send(.incrementButtonTapped) {","  \/\/ ...","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This closure is handed a mutable variable that represents the state of the feature ","type":"text"},{"inlineContent":[{"type":"text","text":"before"}],"type":"emphasis"},{"text":" sending","type":"text"},{"text":" ","type":"text"},{"text":"the action, and it is your job to make the appropriate mutations to it to get it into the shape","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it should be after sending the action:"}]},{"syntax":"swift","type":"codeListing","code":["await store.send(.incrementButtonTapped) {","  $0.count = 1","}"]},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl","type":"reference","isActive":true},{"type":"text","text":" method is "},{"type":"codeVoice","code":"async"},{"type":"text","text":" for technical reasons that we"},{"type":"text","text":" "},{"text":"do not have to worry about right now.","type":"text"}]}],"name":"Note"},{"inlineContent":[{"type":"text","text":"If your mutation is incorrect, meaning you perform a mutation that is different from what happened"},{"text":" ","type":"text"},{"type":"text","text":"in the "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true},{"type":"text","text":", then you will get a test failure with a nicely formatted message showing exactly"},{"text":" ","type":"text"},{"type":"text","text":"what part of the state does not match:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["await store.send(.incrementButtonTapped) {","  $0.count = 999","}"]},{"type":"aside","name":"❌ Failure","style":"note","content":[{"inlineContent":[{"type":"text","text":"A state change does not match expectation: …"}],"type":"paragraph"},{"type":"codeListing","syntax":"diff","code":["- TestStoreTests.State(count: 999)","+ TestStoreTests.State(count: 1)"]},{"inlineContent":[{"text":"(Expected: −, Actual: +)","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"text":"You can also send multiple actions to emulate a script of user actions and assert each step of the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"way how the state evolved:"}]},{"syntax":"swift","type":"codeListing","code":["await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.incrementButtonTapped) {","  $0.count = 2","}","await store.send(.decrementButtonTapped) {","  $0.count = 1","}"]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Technically we could have written the mutation block in the following manner:"}]},{"code":["await store.send(.incrementButtonTapped) {","  $0.count += 1","}","await store.send(.decrementButtonTapped) {","  $0.count -= 1","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"…and the test would have still passed.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"However, this does not produce as strong of an assertion. It shows that the count did increment","type":"text"},{"type":"text","text":" "},{"text":"by one, but we haven’t proven we know the precise value of ","type":"text"},{"type":"codeVoice","code":"count"},{"type":"text","text":" at each step of the way."}]},{"inlineContent":[{"type":"text","text":"In general, the less logic you have in the trailing closure of"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl"},{"text":", the stronger your assertion will be. It is best to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"use simple, hard-coded data for the mutation."}],"type":"paragraph"}],"type":"aside","style":"tip","name":"Tip"},{"inlineContent":[{"text":"Test stores do expose a ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state","isActive":true},{"type":"text","text":" property, which can be useful for performing assertions"},{"type":"text","text":" "},{"type":"text","text":"on computed properties you might have defined on your state. For example, if "},{"code":"State","type":"codeVoice"},{"text":" had a","type":"text"},{"type":"text","text":" "},{"text":"computed property for checking if ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" was prime, we could test it like so:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["store.send(.incrementButtonTapped) {","  $0.count = 3","}","XCTAssertTrue(store.state.isPrime)"]},{"type":"paragraph","inlineContent":[{"text":"However, when inside the trailing closure of ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl","type":"reference","isActive":true},{"type":"text","text":", the"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state"},{"text":" property is equal to the state ","type":"text"},{"inlineContent":[{"type":"text","text":"before"}],"type":"emphasis"},{"type":"text","text":" sending the action, not after. That"},{"type":"text","text":" "},{"text":"prevents you from being able to use an escape hatch to get around needing to actually describe the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"state mutation, like so:"}]},{"type":"codeListing","code":["store.send(.incrementButtonTapped) {","  $0 = store.state  \/\/ ❌ store.state is the previous, not current, state.","}"],"syntax":"swift"},{"type":"heading","level":2,"anchor":"Testing-effects","text":"Testing effects"},{"inlineContent":[{"text":"Testing state mutations as shown in the previous section is powerful, but is only half the story","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when it comes to testing features built in the Composable Architecture. The second responsibility of"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true},{"text":"s, after mutating state from an action, is to return an ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":" that encapsulates a"},{"type":"text","text":" "},{"text":"unit of work that runs in the outside world and feeds data back into the system.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Effects form a major part of a feature’s logic. They can perform network requests to external"},{"type":"text","text":" "},{"text":"services, load and save data to disk, start and stop timers, interact with Apple frameworks (Core","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Location, Core Motion, Speech Recognition, etc.), and more."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As a simple example, suppose we have a feature with a button such that when you tap it, it starts"},{"type":"text","text":" "},{"text":"a timer that counts up until you reach 5, and then stops. This can be accomplished using the","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect\/run(priority:operation:catch:fileID:filePath:line:column:)","isActive":true},{"text":" helper on ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","isActive":true,"type":"reference"},{"text":", which provides you with","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an asynchronous context to operate in and can send multiple actions back into the system:"}]},{"code":["@Reducer","struct Feature {","  @ObservableState","  struct State: Equatable {","    var count = 0","  }","  enum Action {","    case startTimerButtonTapped","    case timerTick","  }","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .startTimerButtonTapped:","        state.count = 0","        return .run { send in","          for _ in 1...5 {","            try await Task.sleep(for: .seconds(1))","            await send(.timerTick)","          }","        }","","      case .timerTick:","        state.count += 1","        return .none","      }","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To test this we can start off similar to how we did in the "},{"overridingTitleInlineContent":[{"text":"previous section","type":"text"}],"isActive":true,"identifier":"#Testing-state-changes","type":"reference","overridingTitle":"previous section"},{"type":"text","text":" "},{"type":"text","text":"when testing state mutations:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","struct TimerTests {","  @Test","  func basics() async {","    let store = TestStore(initialState: Feature.State(count: 0)) {","      Feature()","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With the basics set up, we can send an action into the system to assert on what happens, such as the"},{"type":"text","text":" "},{"code":".startTimerButtonTapped","type":"codeVoice"},{"type":"text","text":" action. This time we don’t actually expect state to change at first"},{"text":" ","type":"text"},{"type":"text","text":"because when starting the timer we don’t change state, and so in this case we can leave off the"},{"type":"text","text":" "},{"text":"trailing closure:","type":"text"}]},{"code":["await store.send(.startTimerButtonTapped)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"However, if we run the test as-is with no further interactions with the test store, we get a"},{"text":" ","type":"text"},{"type":"text","text":"failure:"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An effect returned for this action is still running. It must complete before the end"},{"type":"text","text":" "},{"type":"text","text":"of the test. …"}]}],"type":"aside","name":"❌ Failure","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is happening because "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"text":" requires you to exhaustively prove how the entire system","type":"text"},{"type":"text","text":" "},{"text":"of your feature evolves over time. If an effect is still running when the test finishes and the","type":"text"},{"text":" ","type":"text"},{"text":"test store did ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"text":" fail then it could be hiding potential bugs. Perhaps the effect is not","type":"text"},{"type":"text","text":" "},{"type":"text","text":"supposed to be running, or perhaps the data it feeds into the system later is wrong. The test store"},{"type":"text","text":" "},{"type":"text","text":"requires all effects to finish."}]},{"inlineContent":[{"type":"text","text":"To get this test passing we need to assert on the actions that are sent back into the system"},{"type":"text","text":" "},{"text":"by the effect. We do this by using the ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:fileID:file:line:column:)-53wic","type":"reference"},{"type":"text","text":" "},{"text":"method, which allows you to assert which action you expect to receive from an effect, as well as how","type":"text"},{"text":" ","type":"text"},{"text":"the state changes after receiving that effect:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["await store.receive(\\.timerTick) {","  $0.count = 1","}"],"syntax":"swift"},{"style":"note","type":"aside","name":"Note","content":[{"inlineContent":[{"type":"text","text":"We are using key path syntax "},{"code":"\\.timerTick","type":"codeVoice"},{"type":"text","text":" to specify the case of the action we expect to"},{"text":" ","type":"text"},{"type":"text","text":"receive. This works because the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer()"},{"type":"text","text":" macro automatically applies"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"@CasePathable","type":"codeVoice"},{"text":" macro to the ","type":"text"},{"type":"codeVoice","code":"Action"},{"type":"text","text":" enum, and "},{"code":"@CasePathable","type":"codeVoice"},{"type":"text","text":" comes from our"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/swift-case-paths"},{"type":"text","text":" library which brings key path syntax to enum cases."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if we run this test we still get a failure because we asserted a "},{"type":"codeVoice","code":"timerTick"},{"type":"text","text":" action was"},{"type":"text","text":" "},{"type":"text","text":"going to be received, but after waiting around for a small amount of time no action was received:"}]},{"content":[{"inlineContent":[{"text":"Expected to receive an action, but received none after 0.1 seconds.","type":"text"}],"type":"paragraph"}],"name":"❌ Failure","type":"aside","style":"note"},{"inlineContent":[{"text":"This is because our timer is on a 1 second interval, and by default","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:fileID:file:line:column:)-53wic"},{"type":"text","text":" only waits for a fraction of a second. This"},{"text":" ","type":"text"},{"type":"text","text":"is because typically you should not be performing real time-based asynchrony in effects, and instead"},{"text":" ","type":"text"},{"type":"text","text":"using a controlled entity, such as a clock, that can be sped up in tests. We will demonstrate this"},{"type":"text","text":" "},{"text":"in a moment, so for now let’s increase the timeout:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["await store.receive(\\.timerTick, timeout: .seconds(2)) {","  $0.count = 1","}"]},{"inlineContent":[{"text":"This assertion now passes, but the overall test is still failing because there are still more","type":"text"},{"text":" ","type":"text"},{"text":"actions to receive. The timer should tick 5 times in total, so we need five ","type":"text"},{"type":"codeVoice","code":"receive"},{"type":"text","text":" assertions:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["await store.receive(\\.timerTick, timeout: .seconds(2)) {","  $0.count = 1","}","await store.receive(\\.timerTick, timeout: .seconds(2)) {","  $0.count = 2","}","await store.receive(\\.timerTick, timeout: .seconds(2)) {","  $0.count = 3","}","await store.receive(\\.timerTick, timeout: .seconds(2)) {","  $0.count = 4","}","await store.receive(\\.timerTick, timeout: .seconds(2)) {","  $0.count = 5","}"]},{"inlineContent":[{"text":"Now the full test suite passes, and we have exhaustively proven how effects are executed in this","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"feature. If in the future we tweak the logic of the effect, like say have it emit 10 times instead"},{"type":"text","text":" "},{"text":"of 5, then we will immediately get a test failure letting us know that we have not properly","type":"text"},{"type":"text","text":" "},{"text":"asserted on how the features evolve over time.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"However, there is something not ideal about how this feature is structured, and that is the fact","type":"text"},{"text":" ","type":"text"},{"text":"that we are doing actual, uncontrolled time-based asynchrony in the effect:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  for _ in 1...5 {","    try await Task.sleep(for: .seconds(1))  \/\/ ⬅️","    await send(.timerTick)","  }","}"]},{"inlineContent":[{"type":"text","text":"This means for our test to run we must actually wait for 5 real world seconds to pass so that we"},{"type":"text","text":" "},{"type":"text","text":"can receive all of the actions from the timer. This makes our test suite far too slow. What if in"},{"type":"text","text":" "},{"text":"the future we need to test a feature that has a timer that emits hundreds or thousands of times?","type":"text"},{"type":"text","text":" "},{"type":"text","text":"We cannot hold up our test suite for minutes or hours just to test that one feature."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"To fix this we need to add a dependency to the reducer that aids in performing time-based","type":"text"},{"type":"text","text":" "},{"text":"asynchrony, but in a way that is controllable. One way to do this is to add a clock as a","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" to the reducer:"}]},{"type":"codeListing","code":["import Clocks","","@Reducer","struct Feature {","  struct State { \/* ... *\/ }","  enum Action { \/* ... *\/ }","  @Dependency(\\.continuousClock) var clock","  \/\/ ...","}"],"syntax":"swift"},{"type":"aside","style":"tip","name":"Tip","content":[{"inlineContent":[{"type":"text","text":"To make use of controllable clocks you must use the "},{"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/swift-clocks","isActive":true},{"text":" library, which","type":"text"},{"type":"text","text":" "},{"text":"is automatically included with the Composable Architecture.","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then the timer effect in the reducer can make use of the clock to sleep rather than reaching"},{"type":"text","text":" "},{"type":"text","text":"out to the uncontrollable "},{"type":"codeVoice","code":"Task.sleep"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  for _ in 1...5 {","    try await self.clock.sleep(for: .seconds(1))","    await send(.timerTick)","  }","}"]},{"name":"Tip","content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"sleep(for:)","type":"codeVoice"},{"type":"text","text":" method on "},{"type":"codeVoice","code":"Clock"},{"type":"text","text":" is provided by the "},{"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/swift-clocks","isActive":true,"overridingTitle":"Swift Clocks","overridingTitleInlineContent":[{"type":"text","text":"Swift Clocks"}]},{"text":" ","type":"text"},{"type":"text","text":"library."}]}],"type":"aside","style":"tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By having a clock as a dependency in the feature we can supply a controlled version in tests, such"},{"text":" ","type":"text"},{"type":"text","text":"as an immediate clock that does not suspend at all when you ask it to sleep:"}]},{"syntax":"swift","code":["let store = TestStore(initialState: Feature.State(count: 0)) {","  Feature()","} withDependencies: {","  $0.continuousClock = ImmediateClock()","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"With that small change we can drop the "},{"code":"timeout","type":"codeVoice"},{"type":"text","text":" arguments from the"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:fileID:file:line:column:)-53wic","isActive":true,"type":"reference"},{"type":"text","text":" invocations:"}],"type":"paragraph"},{"code":["await store.receive(\\.timerTick) {","  $0.count = 1","}","await store.receive(\\.timerTick) {","  $0.count = 2","}","await store.receive(\\.timerTick) {","  $0.count = 3","}","await store.receive(\\.timerTick) {","  $0.count = 4","}","await store.receive(\\.timerTick) {","  $0.count = 5","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"…and the test still passes, but now does so immediately."}]},{"inlineContent":[{"text":"The more time you take to control the dependencies your features use, the easier it will be to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"write tests for your features. To learn more about designing dependencies and how to best leverage"},{"text":" ","type":"text"},{"text":"dependencies, read the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","isActive":true},{"text":" article.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Non-exhaustive testing","anchor":"Non-exhaustive-testing","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The previous sections describe in detail how to write tests in the Composable Architecture that","type":"text"},{"text":" ","type":"text"},{"text":"exhaustively prove how the entire feature evolves over time. You must assert on how every piece","type":"text"},{"text":" ","type":"text"},{"text":"of state changes, how every effect feeds data back into the system, and you must even make sure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that all effects complete before the test store is deallocated. This can be powerful, but it can"},{"type":"text","text":" "},{"type":"text","text":"also be a nuisance, especially for highly composed features. This is why sometimes you may want"},{"text":" ","type":"text"},{"text":"to test in a non-exhaustive style.","type":"text"}]},{"type":"aside","content":[{"inlineContent":[{"text":"The concept of “non-exhaustive test store” was first introduced by","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/www.merowing.info"},{"type":"text","text":" in a "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/"},{"type":"text","text":" and"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/vimeo.com\/751173570"},{"text":", and then later became integrated into the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"core library."}],"type":"paragraph"}],"style":"tip","name":"Tip"},{"inlineContent":[{"type":"text","text":"This style of testing is most useful for testing the integration of multiple features where you want"},{"type":"text","text":" "},{"type":"text","text":"to focus on just a certain slice of the behavior. Exhaustive testing can still be important to use"},{"text":" ","type":"text"},{"type":"text","text":"for leaf node features, where you truly do want to assert on everything happening inside the"},{"type":"text","text":" "},{"type":"text","text":"feature."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, suppose you have a tab-based application where the 3rd tab is a login screen. The user"},{"text":" ","type":"text"},{"type":"text","text":"can fill in some data on the screen, then tap the “Submit” button, and then a series of events"},{"type":"text","text":" "},{"text":"happens to  log the user in. Once the user is logged in, the 3rd tab switches from a login screen","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to a profile screen, "},{"inlineContent":[{"text":"and","type":"text"}],"type":"emphasis"},{"type":"text","text":" the selected tab switches to the first tab, which is an activity screen."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"When writing tests for the login feature we will want to do that in the exhaustive style so that we"},{"type":"text","text":" "},{"type":"text","text":"can prove exactly how the feature would behave in production. But, suppose we wanted to write an"},{"type":"text","text":" "},{"type":"text","text":"integration test that proves after the user taps the “Login” button that ultimately the selected"},{"type":"text","text":" "},{"text":"tab switches to the first tab.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In order to test such a complex flow we must test the integration of multiple features, which means","type":"text"},{"type":"text","text":" "},{"text":"dealing with complex, nested state and effects. We can emulate this flow in a test by sending","type":"text"},{"text":" ","type":"text"},{"text":"actions that mimic the user logging in, and then eventually assert that the selected tab switched","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to activity:"}]},{"syntax":"swift","type":"codeListing","code":["let store = TestStore(initialState: AppFeature.State()) {","  AppFeature()","}","","\/\/ 1️⃣ Emulate user tapping on submit button.","await store.send(\\.login.submitButtonTapped) {","  \/\/ 2️⃣ Assert how all state changes in the login feature","  $0.login?.isLoading = true","  \/\/ ...","}","","\/\/ 3️⃣ Login feature performs API request to login, and","\/\/    sends response back into system.","await store.receive(\\.login.loginResponse.success) {","\/\/ 4️⃣ Assert how all state changes in the login feature","  $0.login?.isLoading = false","  \/\/ ...","}","","\/\/ 5️⃣ Login feature sends a delegate action to let parent","\/\/    feature know it has successfully logged in.","await store.receive(\\.login.delegate.didLogin) {","\/\/ 6️⃣ Assert how all of app state changes due to that action.","  $0.authenticatedTab = .loggedIn(","    Profile.State(...)","  )","  \/\/ ...","  \/\/ 7️⃣ *Finally* assert that the selected tab switches to activity.","  $0.selectedTab = .activity","}"]},{"inlineContent":[{"type":"text","text":"Doing this with exhaustive testing is verbose, and there are a few problems with this:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"We need to be intimately knowledgeable in how the login feature works so that we can assert"},{"text":" ","type":"text"},{"text":"on how its state changes and how its effects feed data back into the system.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If the login feature were to change its logic we may get test failures here even though the"},{"text":" ","type":"text"},{"text":"logic we are actually trying to test doesn’t really care about those changes.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This test is very long, and so if there are other similar but slightly different flows we want"},{"type":"text","text":" "},{"type":"text","text":"to test we will be tempted to copy-and-paste the whole thing, leading to lots of duplicated,"},{"text":" ","type":"text"},{"type":"text","text":"fragile tests."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-exhaustive testing allows us to test the high-level flow that we are concerned with, that of"},{"text":" ","type":"text"},{"type":"text","text":"login causing the selected tab to switch to activity, without having to worry about what is"},{"type":"text","text":" "},{"text":"happening inside the login feature. To do this, we can turn off ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","type":"reference"},{"type":"text","text":" in the"},{"text":" ","type":"text"},{"text":"test store, and then just assert on what we are interested in:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(initialState: AppFeature.State()) {","  AppFeature()","}","store.exhaustivity = .off  \/\/ ⬅️","","await store.send(\\.login.submitButtonTapped)","await store.receive(\\.login.delegate.didLogin) {","  $0.selectedTab = .activity","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In particular, we did not assert on how the login’s state changed or how the login’s effects fed"},{"type":"text","text":" "},{"type":"text","text":"data back into the system. We just assert that when the “Submit” button is tapped that eventually"},{"text":" ","type":"text"},{"type":"text","text":"we get the "},{"type":"codeVoice","code":"didLogin"},{"text":" delegate action and that causes the selected tab to flip to activity. Now","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the login feature is free to make any change it wants to make without affecting this integration"},{"type":"text","text":" "},{"type":"text","text":"test."}]},{"inlineContent":[{"type":"text","text":"Using "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off","type":"reference","isActive":true},{"type":"text","text":" for "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","isActive":true,"type":"reference"},{"type":"text","text":" causes all un-asserted changes to pass"},{"type":"text","text":" "},{"text":"without any notification. If you would like to see what test failures are being suppressed without","type":"text"},{"text":" ","type":"text"},{"text":"actually causing a failure, you can use ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)","isActive":true},{"text":":","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(initialState: AppFeature.State()) {","  AppFeature()","}","store.exhaustivity = .off(showSkippedAssertions: true)  \/\/ ⬅️","","await store.send(\\.login.submitButtonTapped)","await store.receive(\\.login.delegate.didLogin) {","  $0.selectedTab = .activity","}"]},{"inlineContent":[{"type":"text","text":"When this is run you will get grey, informational boxes on each assertion where some change wasn’t"},{"text":" ","type":"text"},{"text":"fully asserted on:","type":"text"}],"type":"paragraph"},{"type":"aside","name":"◽️ Expected failure","content":[{"type":"paragraph","inlineContent":[{"text":"A state change does not match expectation: …","type":"text"}]},{"type":"codeListing","code":["  AppFeature.State(","    authenticatedTab: .loggedOut(","      Login.State(","-       isLoading: false","+       isLoading: true,","        …","      )","    )","  )"],"syntax":"diff"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Skipped receiving .login(.loginResponse(.success))"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A state change does not match expectation: …"}]},{"syntax":"diff","code":["  AppFeature.State(","-   authenticatedTab: .loggedOut(…)","+   authenticatedTab: .loggedIn(","+     Profile.State(…)","+   ),","    …","  )"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"(Expected: −, Actual: +)"}],"type":"paragraph"}],"style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The test still passes, and none of these notifications are test failures. They just let you know"},{"text":" ","type":"text"},{"type":"text","text":"what things you are not explicitly asserting against, and can be useful to see when tracking down"},{"text":" ","type":"text"},{"text":"bugs that happen in production but that aren’t currently detected in tests.","type":"text"}]},{"type":"heading","level":4,"anchor":"Understanding-non-exhaustive-testing","text":"Understanding non-exhaustive testing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It can be important to understand how non-exhaustive testing works under the hood because it does"},{"text":" ","type":"text"},{"text":"limit the ways in which you can assert on state changes.","type":"text"}]},{"inlineContent":[{"text":"When you construct an ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"exhaustive","type":"text"}]},{"text":" test store, which is the default, the ","type":"text"},{"type":"codeVoice","code":"$0"},{"text":" used inside the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"trailing closure of "},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl","type":"reference"},{"type":"text","text":" represents the state "},{"inlineContent":[{"text":"before","type":"text"}],"type":"emphasis"},{"text":" the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"action is sent:"}],"type":"paragraph"},{"type":"codeListing","code":["let store = TestStore(\/* ... *\/)","\/\/ ℹ️ \"on\" is the default so technically this is not needed","store.exhaustivity = .on","","store.send(.buttonTapped) {","  $0  \/\/ Represents the state *before* the action was sent","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"This forces you to apply any mutations necessary to "},{"code":"$0","type":"codeVoice"},{"type":"text","text":" to match the state "},{"inlineContent":[{"type":"text","text":"after"}],"type":"emphasis"},{"type":"text","text":" the action"},{"type":"text","text":" "},{"text":"is sent.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Non-exhaustive test stores flip this on its head. In such a test store, the ","type":"text"},{"code":"$0","type":"codeVoice"},{"text":" handed to the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"trailing closure of "},{"code":"send","type":"codeVoice"},{"type":"text","text":" represents the state "},{"type":"emphasis","inlineContent":[{"text":"after","type":"text"}]},{"type":"text","text":" the action was sent:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(\/* ... *\/)","store.exhaustivity = .off","","store.send(.buttonTapped) {","  $0  \/\/ Represents the state *after* the action was sent","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This means you don’t have to make any mutations to "},{"type":"codeVoice","code":"$0"},{"text":" at all and the assertion will already pass.","type":"text"},{"type":"text","text":" "},{"text":"But, if you do make a mutation, then it must match what is already in the state, thus allowing you","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to assert on only the state changes you are interested in."}]},{"type":"paragraph","inlineContent":[{"text":"However, this difference between how ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"text":" behaves when run in exhaustive mode versus","type":"text"},{"text":" ","type":"text"},{"text":"non-exhaustive mode does restrict the kinds of mutations you can make inside the trailing closure of","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"send"},{"text":". For example, suppose you had an action in your feature that removes the last element of a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"collection:"}]},{"syntax":"swift","code":["case .removeButtonTapped:","  state.values.removeLast()","  return .none"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"To test this in an exhaustive store it is completely fine to do this:"}],"type":"paragraph"},{"syntax":"swift","code":["await store.send(.removeButtonTapped) {","  $0.values.removeLast()","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This works because "},{"type":"codeVoice","code":"$0"},{"text":" is the state before the action is sent, and so we can remove the last","type":"text"},{"type":"text","text":" "},{"type":"text","text":"element to prove that the reducer does the same work."}]},{"inlineContent":[{"text":"However, in a non-exhaustive store this will not work:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["store.exhaustivity = .off","await store.send(.removeButtonTapped) {","  $0.values.removeLast()  \/\/ ❌","}"]},{"inlineContent":[{"type":"text","text":"This will either fail, or possibly even crash the test suite. This is because in a non-exhaustive"},{"type":"text","text":" "},{"text":"test store, ","type":"text"},{"type":"codeVoice","code":"$0"},{"text":" in the trailing closure of ","type":"text"},{"code":"send","type":"codeVoice"},{"type":"text","text":" represents the state "},{"inlineContent":[{"type":"text","text":"after"}],"type":"emphasis"},{"text":" the action has been","type":"text"},{"type":"text","text":" "},{"type":"text","text":"sent, and so the last element has already been removed. By executing "},{"code":"$0.values.removeLast()","type":"codeVoice"},{"text":" we are","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"just removing an additional element from the end."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"So, for non-exhaustive test stores you cannot use “relative” mutations for assertions. That is, you","type":"text"},{"text":" ","type":"text"},{"text":"cannot mutate via methods like ","type":"text"},{"type":"codeVoice","code":"removeLast"},{"text":", ","type":"text"},{"code":"append","type":"codeVoice"},{"text":", and anything that incrementally applies a","type":"text"},{"text":" ","type":"text"},{"text":"mutation. Instead you must perform an “absolute” mutation, where you fully replace the collection","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with its final value:"}]},{"syntax":"swift","type":"codeListing","code":["store.exhaustivity = .off","await store.send(.removeButtonTapped) {","  $0.values = []","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or you can weaken the assertion by asserting only on the count of its elements rather than the"},{"type":"text","text":" "},{"text":"content of the element:","type":"text"}]},{"code":["store.exhaustivity = .off","await store.send(.removeButtonTapped) {","  XCTAssertEqual($0.values.count, 0)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Further, when using non-exhaustive test stores that also show skipped assertions (via","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)","isActive":true},{"type":"text","text":"), then there is another caveat to keep in mind. In"},{"text":" ","type":"text"},{"type":"text","text":"such test stores, the trailing closure of "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl","type":"reference","isActive":true},{"text":" is invoked","type":"text"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"twice","type":"text"}]},{"type":"text","text":" by the test store. First with "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" representing the state after the action is sent to see if"},{"type":"text","text":" "},{"type":"text","text":"it does not match the true state, and then again with "},{"code":"$0","type":"codeVoice"},{"type":"text","text":" representing the state before the action"},{"type":"text","text":" "},{"text":"is sent so that we can show what state assertions were skipped.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Because the test store can invoke your trailing assertion closure twice you must be careful if your"},{"type":"text","text":" "},{"type":"text","text":"closure performs any side effects, because those effects will be executed twice. For example,"},{"type":"text","text":" "},{"text":"suppose you have a domain model that uses the controllable ","type":"text"},{"code":"@Dependency(\\.uuid)","type":"codeVoice"},{"type":"text","text":" to generate a UUID:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Model: Equatable {","  let id: UUID","  init() {","    @Dependency(\\.uuid) var uuid","    self.id = uuid()","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a perfectly fine to pattern to adopt in the Composable Architecture, but it does cause"},{"type":"text","text":" "},{"text":"trouble when using non-exhaustive test stores and showing skipped assertions. To see this, consider","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the following simple reducer that appends a new model to an array when an action is sent:"}]},{"syntax":"swift","code":["@Reducer","struct Feature {","  struct State: Equatable {","    var values: [Model] = []","  }","  enum Action {","    case addButtonTapped","  }","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .addButtonTapped:","        state.values.append(Model())","        return .none","      }","    }","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"We’d like to be able to write a test for this by asserting that when the ","type":"text"},{"code":"addButtonTapped","type":"codeVoice"},{"type":"text","text":" action"},{"type":"text","text":" "},{"type":"text","text":"is sent a model is append to the "},{"code":"values","type":"codeVoice"},{"text":" array:","type":"text"}]},{"type":"codeListing","code":["@Test","func add() async {","  let store = TestStore(initialState: Feature.State()) {","    Feature()","  } withDependencies: {","    $0.uuid = .incrementing","  }","  store.exhaustivity = .off(showSkippedAssertions: true)","","  await store.send(.addButtonTapped) {","    $0.values = [Model()]","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"While we would expect this simple test to pass, it fails when "},{"type":"codeVoice","code":"showSkippedAssertions"},{"type":"text","text":" is set to"},{"type":"text","text":" "},{"type":"codeVoice","code":"true"},{"type":"text","text":":"}]},{"style":"note","name":"❌ Failure","content":[{"type":"paragraph","inlineContent":[{"text":"A state change does not match expectation: …","type":"text"}]},{"syntax":"diff","type":"codeListing","code":["  TestStoreNonExhaustiveTests.Feature.State(","    values: [","      [0]: TestStoreNonExhaustiveTests.Model(","-       id: UUID(00000000-0000-0000-0000-000000000001)","+       id: UUID(00000000-0000-0000-0000-000000000000)","      )","    ]","  )"]},{"inlineContent":[{"text":"(Expected: −, Actual: +)","type":"text"}],"type":"paragraph"}],"type":"aside"},{"type":"paragraph","inlineContent":[{"text":"This is happening because the trailing closure is invoked twice, and the side effect that is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"executed when the closure is first invoked is bleeding over into when it is invoked a second time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In particular, when the closure is evaluated the first time it causes "},{"type":"codeVoice","code":"Model()"},{"text":" to be constructed,","type":"text"},{"type":"text","text":" "},{"text":"which secretly generates the next auto-incrementing UUID. Then, when we run the closure again","type":"text"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"another"}]},{"type":"text","text":" "},{"code":"Model()","type":"codeVoice"},{"type":"text","text":" is constructed, which causes another auto-incrementing UUID to be generated,"},{"type":"text","text":" "},{"type":"text","text":"and that value does not match our expectations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want to use the "},{"type":"codeVoice","code":"showSkippedAssertions"},{"type":"text","text":" option for"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)"},{"type":"text","text":" then you should avoid performing any kind of side"},{"type":"text","text":" "},{"text":"effect in ","type":"text"},{"code":"send","type":"codeVoice"},{"type":"text","text":", including using "},{"code":"@Dependency","type":"codeVoice"},{"type":"text","text":" directly in your models’ initializers. Instead"},{"type":"text","text":" "},{"type":"text","text":"force those values to be provided at the moment of initializing the model:"}]},{"code":["struct Model: Equatable {","  let id: UUID","  init(id: UUID) {","    self.id = id","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"And then move the responsibility of generating new IDs to the reducer:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct Feature {","  \/\/ ...","  @Dependency(\\.uuid) var uuid","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .addButtonTapped:","        state.values.append(Model(id: self.uuid()))","        return .none","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"And now you can write the test more simply by providing the ID explicitly:","type":"text"}]},{"code":["await store.send(.addButtonTapped) {","  $0.values = [","    Model(id: UUID(0))","  ]","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And it works if you send the action multiple times:"}]},{"code":["await store.send(.addButtonTapped) {","  $0.values = [","    Model(id: UUID(0))","  ]","}","await store.send(.addButtonTapped) {","  $0.values = [","    Model(id: UUID(0)),","    Model(id: UUID(1))","  ]","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Testing-gotchas","type":"heading","text":"Testing gotchas","level":2},{"anchor":"Testing-host-application","text":"Testing host application","level":3,"type":"heading"},{"inlineContent":[{"text":"This is not well known, but when an application target runs tests it actually boots up a simulator","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and runs your actual application entry point in the simulator. This means while tests are running,"},{"type":"text","text":" "},{"type":"text","text":"your application’s code is separately also running. This can be a huge gotcha because it means you"},{"text":" ","type":"text"},{"text":"may be unknowingly making network requests, tracking analytics, writing data to user defaults or to","type":"text"},{"text":" ","type":"text"},{"text":"the disk, and more.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"This usually flies under the radar and you just won’t know it’s happening, which can be problematic.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"But, once you start using this library and start controlling your dependencies, the problem can"},{"text":" ","type":"text"},{"type":"text","text":"surface in a very visible manner. Typically, when a dependency is used in a test context without"},{"text":" ","type":"text"},{"type":"text","text":"being overridden, a test failure occurs. This makes it possible for your test to pass successfully,"},{"type":"text","text":" "},{"type":"text","text":"yet for some mysterious reason the test suite fails. This happens because the code in the "},{"inlineContent":[{"type":"text","text":"app"},{"text":" ","type":"text"},{"type":"text","text":"host"}],"type":"emphasis"},{"text":" is now running in a test context, and accessing dependencies will cause test failures.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This only happens when running tests in a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"application target"}]},{"type":"text","text":", that is, a target that is"},{"type":"text","text":" "},{"text":"specifically used to launch the application for a simulator or device. This does not happen when","type":"text"},{"text":" ","type":"text"},{"text":"running tests for frameworks or SPM libraries, which is yet another good reason to modularize","type":"text"},{"type":"text","text":" "},{"text":"your code base.","type":"text"}]},{"inlineContent":[{"type":"text","text":"However, if you aren’t in a position to modularize your code base right now, there is a quick"},{"type":"text","text":" "},{"type":"text","text":"fix. Our "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay"},{"text":" library, which is transitively included","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with this library, comes with a property you can check to see if tests are currently running. If"},{"type":"text","text":" "},{"text":"they are, you can omit the entire entry point of your application:","type":"text"}],"type":"paragraph"},{"code":["import SwiftUI","import ComposableArchitecture","","@main","struct MyApp: App {","  var body: some Scene {","    WindowGroup {","      if TestContext.current == nil{","        \/\/ Your real root view","      }","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"That will allow tests to run in the application target without your actual application code","type":"text"},{"type":"text","text":" "},{"type":"text","text":"interfering."}],"type":"paragraph"},{"text":"Statically linking your tests target to ComposableArchitecture","level":3,"type":"heading","anchor":"Statically-linking-your-tests-target-to-ComposableArchitecture"},{"type":"paragraph","inlineContent":[{"text":"If you statically link the ","type":"text"},{"code":"ComposableArchitecture","type":"codeVoice"},{"text":" module to your tests target, its implementation","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"may clash with the implementation that is statically linked to the app itself. The most usually"},{"type":"text","text":" "},{"type":"text","text":"manifests by getting mysterious test failures telling you that you are using live dependencies in"},{"type":"text","text":" "},{"text":"your tests even though you have overridden your dependencies.","type":"text"}]},{"inlineContent":[{"type":"text","text":"In such cases Xcode will display multiple warnings in the console similar to:"}],"type":"paragraph"},{"type":"aside","name":"Note","content":[{"inlineContent":[{"type":"text","text":"Class _TtC12Dependencies[…] is implemented in both […] and […]."},{"text":" ","type":"text"},{"text":"One of the two will be used. Which one is undefined.","type":"text"}],"type":"paragraph"}],"style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The solution is to remove the static link to "},{"type":"codeVoice","code":"ComposableArchitecture"},{"text":" from your test target, as you","type":"text"},{"text":" ","type":"text"},{"text":"transitively get access to it through the app itself. In Xcode, go to “Build Phases” and remove","type":"text"},{"text":" ","type":"text"},{"text":"“ComposableArchitecture” from the “Link Binary With Libraries” section. When using SwiftPM, remove","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the “ComposableArchitecture” entry from the "},{"type":"codeVoice","code":"testTarget"},{"type":"text","text":"‘s’ "},{"type":"codeVoice","code":"dependencies"},{"text":" array in ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"heading","level":3,"anchor":"Long-living-test-stores","text":"Long-living test stores"},{"type":"paragraph","inlineContent":[{"text":"Test stores should always be created in individual tests when possible, rather than as a shared","type":"text"},{"type":"text","text":" "},{"type":"text","text":"instance variable on the test class:"}]},{"type":"codeListing","code":[" @MainActor"," struct FeatureTests {","   \/\/ 👎 Don't do this:","-  let store = TestStore(initialState: Feature.State()) {","-    Feature()","-  }","","   @Test","   func basics() async {","     \/\/ 👍 Do this:","+    let store = TestStore(initialState: Feature.State()) {","+      Feature()","+    }","     \/\/ ...","   }"," }"],"syntax":"diff"},{"inlineContent":[{"type":"text","text":"This allows you to be very precise in each test: you can start the store in a very specific state,"},{"text":" ","type":"text"},{"type":"text","text":"and override just the dependencies a test cares about."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"More crucially, test stores that are held onto by the test class will not be deinitialized during a"},{"text":" ","type":"text"},{"type":"text","text":"test run, and so various exhaustive assertions made during deinitialization will not be made,"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"e.g.","type":"text"}]},{"type":"text","text":" that the test store has unreceived actions that should be asserted against, or in-flight"},{"text":" ","type":"text"},{"type":"text","text":"effects that should complete."}]},{"inlineContent":[{"text":"If a test store does ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"emphasis"},{"text":" deinitialize at the end of a test, you must explicitly call","type":"text"},{"type":"text","text":" "},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/finish(timeout:fileID:file:line:column:)-klnc","type":"reference"},{"text":" at the end of the test to retain","type":"text"},{"text":" ","type":"text"},{"text":"exhaustive coverage:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["await store.finish()"],"type":"codeListing"}],"kind":"content"}],"metadata":{"roleHeading":"Article","role":"article","title":"Testing","modules":[{"name":"ComposableArchitecture"}]},"variants":[{"paths":["\/documentation\/composablearchitecture\/testing"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/Exhaustivity/off":{"kind":"symbol","abstract":[{"type":"text","text":"Non-exhaustive assertions."}],"title":"off","type":"topic","url":"\/documentation\/composablearchitecture\/exhaustivity\/off","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"off"},{"text":": ","kind":"text"},{"text":"Exhaustivity","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture12ExhaustivityO"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Effect/run(priority:operation:catch:fileID:filePath:line:column:)":{"abstract":[{"text":"Wraps an asynchronous unit of work that can emit actions any number of times in an effect.","type":"text"}],"role":"symbol","url":"\/documentation\/composablearchitecture\/effect\/run(priority:operation:catch:fileid:filepath:line:column:)","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect\/run(priority:operation:catch:fileID:filePath:line:column:)","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"run","kind":"identifier"},{"kind":"text","text":"("},{"kind":"externalParam","text":"priority"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:ScP","text":"TaskPriority"},{"text":"?, ","kind":"text"},{"kind":"externalParam","text":"operation"},{"text":": (","kind":"text"},{"text":"Send","preciseIdentifier":"s:22ComposableArchitecture4SendV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Action","kind":"typeIdentifier"},{"text":">) ","kind":"text"},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"preciseIdentifier":"s:s4Voida","kind":"typeIdentifier","text":"Void"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"catch"},{"text":": ((any ","kind":"text"},{"preciseIdentifier":"s:s5ErrorP","text":"Error","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Send","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture4SendV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":">) "},{"text":"async","kind":"keyword"},{"text":" -> ","kind":"text"},{"preciseIdentifier":"s:s4Voida","text":"Void","kind":"typeIdentifier"},{"text":")?, ","kind":"text"},{"kind":"externalParam","text":"fileID"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV","text":"StaticString"},{"kind":"text","text":", "},{"text":"filePath","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"StaticString","preciseIdentifier":"s:s12StaticStringV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"line"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Su","kind":"typeIdentifier","text":"UInt"},{"text":", ","kind":"text"},{"text":"column","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:22ComposableArchitecture6EffectV","kind":"typeIdentifier","text":"Effect"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":">"}],"title":"run(priority:operation:catch:fileID:filePath:line:column:)","kind":"symbol","type":"topic"},"#Testing-gotchas":{"url":"#Testing-gotchas","type":"link","identifier":"#Testing-gotchas","titleInlineContent":[{"text":"Testing gotchas","type":"text"}],"title":"Testing gotchas"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/send(_:assert:fileID:file:line:column:)-8f2pl":{"type":"topic","title":"send(_:assert:fileID:file:line:column:)","kind":"symbol","abstract":[{"type":"text","text":"Sends an action to the store and asserts when state changes."}],"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"send","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"text":"assert","kind":"externalParam"},{"kind":"text","text":": (("},{"text":"inout","kind":"keyword"},{"kind":"text","text":" "},{"text":"State","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s4Voida","text":"Void"},{"kind":"text","text":")?, "},{"text":"fileID","kind":"externalParam"},{"kind":"text","text":": "},{"text":"StaticString","kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"file"},{"text":": ","kind":"text"},{"text":"StaticString","preciseIdentifier":"s:s12StaticStringV","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"preciseIdentifier":"s:Su","kind":"typeIdentifier","text":"UInt"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"column"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Su","text":"UInt","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"TestStoreTask","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture13TestStoreTaskV"}],"conformance":{"constraints":[{"code":"State","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:fileID:file:line:column:)-8f2pl","url":"\/documentation\/composablearchitecture\/teststore\/send(_:assert:fileid:file:line:column:)-8f2pl","role":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/exhaustivity":{"kind":"symbol","abstract":[{"type":"text","text":"The current exhaustivity level of the test store."}],"type":"topic","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"text":"exhaustivity","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Exhaustivity","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture12ExhaustivityO"}],"role":"symbol","url":"\/documentation\/composablearchitecture\/teststore\/exhaustivity","title":"exhaustivity","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"url":"\/documentation\/composablearchitecture","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"text":" ","type":"text"},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","role":"collection","type":"topic"},"http://github.com/pointfreeco/swift-case-paths":{"url":"http:\/\/github.com\/pointfreeco\/swift-case-paths","type":"link","identifier":"http:\/\/github.com\/pointfreeco\/swift-case-paths","titleInlineContent":[{"type":"text","text":"CasePaths"}],"title":"CasePaths"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","role":"symbol","title":"Effect","navigatorTitle":[{"text":"Effect","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/composablearchitecture\/effect","abstract":[],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Effect","kind":"identifier"}],"type":"topic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyManagement":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","url":"\/documentation\/composablearchitecture\/dependencymanagement","role":"article","title":"Dependencies","abstract":[{"type":"text","text":"Learn how to register dependencies with the library so that they can be immediately accessible from"},{"text":" ","type":"text"},{"type":"text","text":"any reducer."}],"type":"topic","kind":"article"},"https://vimeo.com/751173570":{"url":"https:\/\/vimeo.com\/751173570","type":"link","identifier":"https:\/\/vimeo.com\/751173570","titleInlineContent":[{"text":"conference talk","type":"text"}],"title":"conference talk"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/receive(_:timeout:assert:fileID:file:line:column:)-53wic":{"fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"receive"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"text":"CaseKeyPath","kind":"typeIdentifier","preciseIdentifier":"s:9CasePaths0A7KeyPatha"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":">, "},{"text":"timeout","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s8DurationV","text":"Duration"},{"kind":"text","text":", "},{"kind":"externalParam","text":"assert"},{"kind":"text","text":": (("},{"text":"inout","kind":"keyword"},{"kind":"text","text":" "},{"text":"State","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"},{"text":" -> ","kind":"text"},{"text":"Void","kind":"typeIdentifier","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"text":"fileID","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:s12StaticStringV","text":"StaticString","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"file","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"line"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Su","kind":"typeIdentifier","text":"UInt"},{"text":", ","kind":"text"},{"text":"column","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:Su","text":"UInt","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"async","kind":"keyword"}],"url":"\/documentation\/composablearchitecture\/teststore\/receive(_:timeout:assert:fileid:file:line:column:)-53wic","role":"symbol","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"State"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"type":"topic","title":"receive(_:timeout:assert:fileID:file:line:column:)","kind":"symbol","abstract":[{"text":"Asserts an action was received matching a case path and asserts how the state changes.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:fileID:file:line:column:)-53wic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Store":{"type":"topic","url":"\/documentation\/composablearchitecture\/store","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Store","kind":"identifier"}],"abstract":[{"text":"A store represents the runtime that powers the application. It is the object that you will pass","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"around to views that need to interact with the application."}],"kind":"symbol","title":"Store","navigatorTitle":[{"text":"Store","kind":"identifier"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Exhaustivity/off(showSkippedAssertions:)":{"abstract":[{"type":"text","text":"Non-exhaustive assertions."}],"url":"\/documentation\/composablearchitecture\/exhaustivity\/off(showskippedassertions:)","role":"symbol","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)","type":"topic","kind":"symbol","title":"Exhaustivity.off(showSkippedAssertions:)","fragments":[{"text":"case","kind":"keyword"},{"text":" ","kind":"text"},{"text":"off","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"showSkippedAssertions"},{"kind":"text","text":": "},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"},{"kind":"text","text":")"}]},"#Testing-effects":{"url":"#Testing-effects","type":"link","identifier":"#Testing-effects","titleInlineContent":[{"type":"text","text":"Testing effects"}],"title":"Testing effects"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/finish(timeout:fileID:file:line:column:)-klnc":{"kind":"symbol","url":"\/documentation\/composablearchitecture\/teststore\/finish(timeout:fileid:file:line:column:)-klnc","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"finish","kind":"identifier"},{"kind":"text","text":"("},{"text":"timeout","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"Duration","preciseIdentifier":"s:s8DurationV"},{"text":", ","kind":"text"},{"text":"fileID","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"file"},{"text":": ","kind":"text"},{"text":"StaticString","preciseIdentifier":"s:s12StaticStringV","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Su","text":"UInt","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"column"},{"text":": ","kind":"text"},{"text":"UInt","preciseIdentifier":"s:Su","kind":"typeIdentifier"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Suspends until all in-flight effects have finished, or until it times out."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/finish(timeout:fileID:file:line:column:)-klnc","role":"symbol","title":"finish(timeout:fileID:file:line:column:)","type":"topic"},"https://www.merowing.info":{"url":"https:\/\/www.merowing.info","type":"link","identifier":"https:\/\/www.merowing.info","titleInlineContent":[{"text":"Krzysztof Zabłocki","type":"text"}],"title":"Krzysztof Zabłocki"},"http://github.com/pointfreeco/swift-clocks":{"url":"http:\/\/github.com\/pointfreeco\/swift-clocks","type":"link","identifier":"http:\/\/github.com\/pointfreeco\/swift-clocks","titleInlineContent":[{"type":"text","text":"Clocks"}],"title":"Clocks"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/state":{"abstract":[{"type":"text","text":"The current state of the test store."}],"role":"symbol","title":"state","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state","url":"\/documentation\/composablearchitecture\/teststore\/state","type":"topic","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"state","kind":"identifier"},{"text":": ","kind":"text"},{"text":"State","kind":"typeIdentifier"}],"kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"type":"topic","url":"\/documentation\/composablearchitecture\/reducer","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"kind":"symbol","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"abstract":[{"text":"A protocol that describes how to evolve the current state of an application to the next state,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"given an action, and describes what "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","isActive":true},{"type":"text","text":"s should be executed later by the store, if any."}],"title":"Reducer"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"url":"\/documentation\/composablearchitecture\/teststore","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"TestStore"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","role":"symbol","type":"topic","abstract":[{"type":"text","text":"A testable runtime for a reducer."}],"title":"TestStore","kind":"symbol","navigatorTitle":[{"text":"TestStore","kind":"identifier"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer()":{"url":"\/documentation\/composablearchitecture\/reducer()","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer()","role":"symbol","title":"Reducer()","abstract":[{"type":"text","text":"Helps implement the conformance to the "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"text":" protocol for a type.","type":"text"}],"fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Reducer"},{"kind":"text","text":"()"}],"type":"topic","kind":"symbol"},"#Testing-state-changes":{"url":"#Testing-state-changes","type":"link","identifier":"#Testing-state-changes","titleInlineContent":[{"text":"Testing state changes","type":"text"}],"title":"Testing state changes"},"http://github.com/pointfreeco/xctest-dynamic-overlay":{"url":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay","type":"link","identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay","titleInlineContent":[{"type":"text","text":"XCTest Dynamic Overlay"}],"title":"XCTest Dynamic Overlay"},"#Non-exhaustive-testing":{"url":"#Non-exhaustive-testing","type":"link","identifier":"#Non-exhaustive-testing","titleInlineContent":[{"text":"Non-exhaustive testing","type":"text"}],"title":"Non-exhaustive testing"},"https://www.merowing.info/exhaustive-testing-in-tca/":{"url":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/","type":"link","identifier":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/","titleInlineContent":[{"type":"text","text":"blog post"}],"title":"blog post"}}}