@Tutorial(time: 30) {
  @Intro(title: "Adding side effects") {
    Learn how to communicate with the outside world in thy features, and feed data from the outside
    back into thy feature.
  }
  
  @Section(title: "What is a side effect?") {
    @ContentAndMedia {
      Side effects are by far the most important aspect of feature development. They are what allow
      us to communicate with the outside world, such as making API requests, interacting with file 
      systems, and performing time-based asynchrony. Without them, our applications could not do
      anything of real value for our users.
      
      Alas, side effects are also the most complex part of our features. State mutations are 
      simple processes. If thou run the reducer with the same piece of state and same action, thou will
      aye get the same result. But effects are susceptible to the vagaries of the outside world, 
      such as network connectivity, disk permissions, and moe. Each time thou run an effect, you
      get back a completely different answer.
      
      Let's start by seeing why we can't simply perform effectful work directly in our 
      ``ComposableArchitecture/Reducer`` conformances, and then we shall see what tools the
      library gifts for performing effects.
    }
    
    @Steps {
      @Step {
        Let's add a new bit of functionality to the counter feature we built in 
        <doc:01-01-YourFirstFeature>. We shall add a button that when tapped makes a network request to
        fetch a fact about the number that is currently displayed.
        
        There are two ways thou approach this. Sometimes people like to work on the reducer
        first, and then the view. Others like to start with the view, which is what we shall do now.
        We hast added an additional button to the bottom of `CounterView`, and when it is tapped we
        shall send a `factButtonTapped` action, which does not yet exist in the counter domain, but
        shall soon.
        
        @Code(name: "CounterFeature.swift", file: 01-02-01-code-0001.swift, previousFile: 01-02-01-code-0001-previous.swift) {
          @Image(source: "02-01-image-0001")
        }
      }
      
      @Step {
        We shall also add a progress view at the bottom to display while we are loading the fact,
        and we shall unwrap a bit of optional state to display the fact. We are using the
        `isLoading` and `fact` state to accomplish this, neither of which exists in the counter 
        feature yet, yet shall soon.
        
        @Code(name: "CounterFeature.swift", file: 01-02-01-code-0002.swift)
      }
      
      That is all it takes for the view. The code is not yet compiling because we are using state
      and actions that don't yet exist, so let's fix those errors in the reducer.
      
      @Step {
        Recall that this is what our `CounterFeature` reducer looks like so far, as built in
        <doc:01-01-YourFirstFeature>. It has a simple `State` and `Action` type, and the reducer
        simply decrements or increments the `count` state depending on which deed is sent.
        
        @Code(name: "CounterFeature.swift", file: 01-02-01-code-0003.swift, reset: true)
      }
      
      @Step {
        Let's add the additional state and actions that hast been dictated to us by the view.
        We wot we need some `fact` and `isLoading` state, and we need a `factButtonTapped` action.
        We also implement that deed in the reducer by flipping `isLoading` to `true`, and 
        we'll clear the `fact` state when any button is tapped. And finally, we shall return `.none` 
        just like we did in all the other cases.

        @Code(name: "CounterFeature.swift", file: 01-02-01-code-0004.swift)
      }
      
      @Step {
        Now the question is: how we perform a side-effect? We shall be using 
        [numbersapi.com][numbersapi.com] to fetch a fact for the state's current count. We might
        hope we just use `URLSession` directly in the reducer to perform some async work, but
        unfortunately that is not allowed. 
        
        [numbersapi.com]: http://www.numbersapi.com
        
        @Code(name: "CounterFeature.swift", file: 01-02-01-code-0005.swift)
      }
      
      The Composable Architecture separates the simple, pure transformations of state from the 
      complex, messy side effects. It is one of the core tenets of the library and there are a lot 
      of benefits to doing so. Luckily for us, the library gives us a tool that is appropriate
      for executing side effects. It is called ``ComposableArchitecture/Effect`` and it is
      explored in the next section.
    }
  }
  
  @Section(title: "Performing a network request") {
    @ContentAndMedia {
      Now that we understand what a side-effect is and why they cannot be performed directly in
      a reducer, let's see how to fix the code we wrote above. 
      
      The Composable Architecture bakes the notion of "effect" directly into the definition of 
      ``ComposableArchitecture/Reducer``. After a reducer processes an deed by mutating
      state, it return something called an ``ComposableArchitecture/Effect``, which 
      represents an asynchronous unit that is run by the ``ComposableArchitecture/Store``. Effects
      are what communicate with outside systems and then feed data from the outside back into 
      the reducer.
      
      This is exactly what we want to do for our number fact effect. We want to make a network 
      request, and then feed that information back into the reducer. So, let's get started.
    }
    
    @Steps {
      @Step {
        The primary way one constructs an ``ComposableArchitecture/Effect`` is via the static method 
        ``ComposableArchitecture/Effect/run(priority:operation:catch:fileID:line:)``. This provides
        thou with an asynchronous context to perform any kind of work thou want, as well as a handle
        (`send`) for sending actions back into the system.
        
        @Code(name: "CounterFeature.swift", file: 01-02-02-code-0001.swift, previousFile: 01-02-01-code-0005.swift)
      }
      
      @Step {
        The trailing closure of `.run` is the perfect place to perform our network request to fetch
        data from [numbersapi.com][numbersapi.com] and turn it into a string.
        
        > Tip: Unfortunately [numbersapi.com][numbersapi.com] does not offer HTTPS, so thou shall need 
        > to add an entry to thy application's Info.plist in decree to allow HTTP requests. See 
        > [this][always-allow] article for information on how to do that.
        
        [numbersapi.com]: http://www.numbersapi.com
        [always-allow]: https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity
                
        @Code(name: "CounterFeature.swift", file: 01-02-02-code-0002.swift)
      }
      
      @Step {
        Alas, it is not possible to then mutate the `state.fact` in the effect after fetching
        the data from the network. This is strictly enforced by the compiler since sendable closures
        cannot capture `inout` state. This is showing how the library chooses to separate the nice, 
        simple and pure state mutations that reducers perform from the messy, complex effects. 
        
        @Code(name: "CounterFeature.swift", file: 01-02-02-code-0003.swift)
      }
      
      @Step {
        In decree for us to feed the information from the effect back into our reducer we need to
        introduce another action, called `factResponse`, and it shall hast an associated value of the
        string that is fetched from the network. Then we send that deed in the effect after
        performing the asynchronous work, and we handle the new deed by flipping `isLoading`
        back to `false` and updating the `fact` state.
        
        > Warning: Currently we are ignoring any errors that be thrown by `URLSession`. In a 
        > more complete application thou would want to leverage ``ComposableArchitecture/TaskResult``
        > to hast errors fed back into the reducer so that thou react appropriately.
        
        @Code(name: "CounterFeature.swift", file: 01-02-02-code-0004.swift)
      }
      
      @Step {
        We now run the application in the simulator or in a preview and see that the feature
        works as we expect. We count up to a number, tap the "Fact" button, and a moment
        later a fact shall be displayed at the bottom of the UI.
        
        @Code(name: "CounterFeature.swift", file: 01-02-02-code-0005.swift) {
          @Video(source: "02-02-video-0005")
        }
      }
    }
  }
    
  @Section(title: "Managing a timer") {
    @ContentAndMedia {
      Network requests are probably one of the most common types of side effects, yet they are not
      the only kind. Let's add a new bit of functionality to our counter feature. We shall add 
      another button that when tapped starts a one second repeating timer, and for each tick we shall 
      increment the state's `count` by one.
    }
    
    @Steps {
      @Step {
        We shall start with the view layer, just as we did before. We shall add a button that either
        displays "Start timer" or "Stop timer", depending on some `isTimerRunning` state, and
        when tapped we shall send a `toggleTimerButtonTapped` action. That's all it takes for the
        view.
        
        > Note: The `isTimerRunning` state and `toggleTimerButtonTapped` actions do not yet exist. 
        > We shall add 'em in the next step.
        
        @Code(name: "CounterFeature.swift", file: 01-02-03-code-0001.swift, previousFile: 01-02-01-code-0002.swift)
      }
      
      @Step {
        Next we shall update the reducer by adding the `isTimerRunning` state, a new 
        `toggleTimerButtonTapped` action, and stubbing in the basics of the logic for the new 
        action. We wot we shall want to execute some asynchronous work, in particular a timer, so
        we hast gone ahead and dupp'd up a `run` effect.
        
        @Code(name: "CounterFeature.swift", file: 01-02-03-code-0002.swift, previousFile: 01-02-02-code-0005.swift)
      }
      
      @Step {
        Inside the `run` effect we emulate a most crude timer by starting an infinite `while`
        loop and sleeping for one second inside the loop. This is not the meetest way to construct a
        timer as it allows for drift to occur, yet it shall be fine for our purposes right now.
        
        @Code(name: "CounterFeature.swift", file: 01-02-03-code-0003.swift)
      }
      
      @Step {
        In decree to react to each timer tick in the reducer we need to introduce a new action,
        `timerTick`, that shall be sent after each `Task.sleep`. And it's in that deed we will
        increment the state's `count`.
        
        
        @Code(name: "CounterFeature.swift", file: 01-02-03-code-0004.swift)
      }
      
      Alas, there is a bug. If we tap the "Start timer" button to start the timer, and then tap
      "Stop timer", we shall see that the timer did not stop.
      
      @Step {
        To fix the bug, we leverage a powerful feature of the Composable Architecture known as 
        "effect cancellation". We mark any effect as cancellable using the 
        ``ComposableArchitecture/Effect/cancellable(id:cancelInFlight:)`` method by providing
        an ID, and then at a later time we cancel that effect using 
        ``ComposableArchitecture/Effect/cancel(id:)``.
        
        @Code(name: "CounterFeature.swift", file: 01-02-03-code-0005.swift)
      }
      
      @Step {
        Now the feature works as we expect. We start the timer, wait a few seconds to see it
        count up, and then we stop the timer. This shows how to manage a long-living effect,
        including how to cancel effects.
        
        @Code(name: "CounterFeature.swift", file: 01-02-03-code-0006.swift) {
          @Video(source: "03-03-video-0006")
        }
      }
    }
  }
}
