@Tutorial(time: 100) { <!-- todo: better estimate --> 
  @Intro(title: "Your first feature") {
    Learn how to create a conformance to ``ComposableArchitecture/ReducerProtocol`` for implementing
    the logic and behavior of a feature, and then learn how to hook up that feature to a SwiftUI
    view.
  }
  
  @Section(title: "Create a reducer") {
    @ContentAndMedia {
      The fundamental unit that features are built with in the Composable Architecture is the
      ``ComposableArchitecture/ReducerProtocol``. A conformance to that protocol represents the 
      logic and behavior for a feature in your application. This includes how to evolve the current
      state to the next state when an action is sent into the system, and how effects communicate
      with the outside world and feed data back into the system.
      
      And most importantly, the feature's core logic and behavior can be built in full isolation
      with no mention of a SwiftUI view, which makes it easier to develop in isolation, easier
      to reuse, and easier to test.
      
      Let's start by creating a simple reducer that encapsulates the logic of a counter. We will
      add more interesting behavior to the feature, but let's start simple for now.
    }
    @Steps {
      @Step {
        Create a new Swift file named CounterFeature.swift and import the Composable Architecture.
        @Code(name: "CounterFeature.swift", file: 01-01-code-0001.swift)
      }
      
      @Step {
        Define a new struct called CounterFeature that conforms to the 
        ``ComposableArchitecture/ReducerProtocol``.
        @Code(name: "CounterFeature.swift", file: 01-01-code-0002.swift)
      }
      
      @Step {
        To conform to ``ComposableArchitecture/ReducerProtocol`` you will start with a domain 
        modeling exercise. You will create a `State` type that holds the state your feature needs 
        to do its job, typically a struct. Then you will create an `Action` type that holds all 
        the actions the user can perform  in the feature, typically an enum. 
        
        @Code(name: "CounterFeature.swift", file: 01-01-code-0003.swift)
      }
      
      @Step {
        For the purpose of a simple counter feature, the state consists of just a single integer,
        the current count, and the actions consist of tapping buttons to either increment or 
        decrement the count.
        
        > Tip: It is best to name the `Action` cases after literally what the user does in the UI,
        such as `incrementButtonTapped`, rather than what logic you want to perform, such as 
        `incrementCount`.
        
        @Code(name: "CounterFeature.swift", file: 01-01-code-0004.swift)
      }
      
      @Step {
        And finally, to finish conforming to ``ComposableArchitecture/ReducerProtocol``, you must
        implement a
        ``ComposableArchitecture/ReducerProtocol/reduce(into:action:)-8yinq`` method
        that evolves the state from its current value to the next value given a user action, and
        returns any effects that the feature wants to execute in the outside world. This almost
        always begins by switching on the incoming action to determine what logic you need to 
        perform.
        
        @Code(name: "CounterFeature.swift", file: 01-01-code-0005.swift)
      }
      
      @Step {
        The logic for this feature is quite simple. We just want to either subtract one or add one
        to the state's count. We must also return a value of ``ComposableArchitecture/EffectTask`` 
        that represents the effect to be executed in the outside world, but in this case we do not 
        need to execute anything. So we can return a special
        ``ComposableArchitecture/EffectPublisher/none`` value to represents we have no effects to
        execute.
        
        @Code(name: "CounterFeature.swift", file: 01-01-code-0006.swift)
      }
      
      @Step {
        That is all it takes to implement a _very_ basic feature in the Composable Architecture.
        There is of course a lot more to know about, such as executing effects and feeding data
        back into the system, using dependencies in reducers, composing multiple reducers together, 
        and a lot more. But we will stop here for this feature right now and move onto the view.
        
        @Code(name: "CounterFeature.swift", file: 01-01-code-0007.swift)
      }
    }
  }
    
  @Section(title: "Integrating with SwiftUI") {
    @ContentAndMedia {
      Now that we have a simple feature built as a reducer, we need to figure out how to power a 
      SwiftUI view from that feature. This involves two new concepts: 
      ``ComposableArchitecture/Store``, which represents the runtime of the feature, and 
      ``ComposableArchitecture/ViewStore``, which represents the observation of the runtime.
    }
    @Steps {
      @Step {
        It is our personal preference to keep the reducer and view in the same file until it is
        untenable, but others prefer to split the types into their own files. For this tutorial
        we will continue putting everything in CounterFeature.swift, and we will now import SwiftUI
        and get a basic view into place:
        
        @Code(name: "CounterFeature.swift", file: 01-02-code-0001.swift)
      }
      
      @Step {
        The first thing one adds to the view is a ``ComposableArchitecture/Store`` that is generic
        over the reducer we constructed in the previous section. The `Store` represents the runtime
        of your feature. That is, it is the object that can process actions in order to update
        state, and it can execute effects and feed data from those effects back into the system.
        
        > Tip: The store can be held onto as a `let`. It does not need to be observed by the view.
        
        @Code(name: "CounterFeature.swift", file: 01-02-code-0002.swift)
      }
      
      @Step {
        Next we can implement some basic view heirachy for displaying the count and providing 
        buttons for incrementing and decrementing. Note that you cannot read state from a 
        ``ComposableArchitecture/Store`` directly, nor can you send actions to it directly. So, 
        for now we will provide stubs for that behavior.
        
        @Code(name: "CounterFeature.swift", file: 01-02-code-0003.swift) {
          @Image(source: "01-02-image-0003.png", alt: "TODO")
        }
      }
      
      @Step {
        With some basic view scaffolding in place we can now start actually observing state in the
        `store`. This is done by constructing a ``ComposableArchitecture/ViewStore``, and for 
        SwiftUI views there is a convenience view called a ``ComposableArchitecture/WithViewStore``
        that provides a lightweight syntax for construct a view store.
        
        Once the view store is constructed we can access the feature's state and send it actions
        when the user taps on buttons.
        
        > Note: Currently we are observing _all_ state in the store by using `observe: { $0 }`, 
        but typically features hold onto a lot more state than what is needed in the view. See
        our article <doc:Performance> for more information on how to best observe only the bare
        essentials a view needs to do its job.
        
        @Code(name: "CounterFeature.swift", file: 01-02-code-0004.swift)
      }
    }
  }
}
