{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dependencies in an application are the types and functions that need to interact with outside"},{"type":"text","text":" "},{"type":"text","text":"systems that you do not control. Classic examples of this are API clients that make network requests"},{"type":"text","text":" "},{"type":"text","text":"to servers, but also seemingly innocuous things such as "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" initializers, and even"},{"type":"text","text":" "},{"type":"text","text":"clocks, can be thought of as dependencies."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By controlling the dependencies our features need to do their job we gain the ability to completely"},{"type":"text","text":" "},{"type":"text","text":"alter the execution context a feature runs in. This means in tests and Xcode previews you can"},{"type":"text","text":" "},{"type":"text","text":"provide a mock version of an API client that immediately returns some stubbed data rather than"},{"type":"text","text":" "},{"type":"text","text":"making a live network request to a server."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#The-need-for-controlled-dependencies"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Using-library-dependencies"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Registering-your-own-dependencies"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Live-preview-and-test-dependencies"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Designing-dependencies"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Overriding-dependencies"}]}]}]},{"anchor":"The-need-for-controlled-dependencies","level":2,"type":"heading","text":"The need for controlled dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose that you are building a todo application with a "},{"type":"codeVoice","code":"Todo"},{"type":"text","text":" model that has a UUID identifier:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todo: Equatable, Identifiable {","  let id: UUID","  var title = \"\"","  var isCompleted = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And suppose you have a reducer that handles an action for when the “Add todo” button is tapped,"},{"type":"text","text":" "},{"type":"text","text":"which appends a new todo to the end of the array:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  struct State {","    var todos: IdentifiedArrayOf<Todo> = []","    \/\/ ...","  }","  enum Action {","    case addButtonTapped","    \/\/ ...","  }","","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    switch action {","    case .addButtonTapped:","      state.todos.append(Todo(id: UUID())","      return .none","","    \/\/ ...","    }","  }","}"]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We are using "},{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" from our"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"},{"type":"text","text":" library because it provides a safe and"},{"type":"text","text":" "},{"type":"text","text":"ergonomic API for accessing elements from a stable ID rather than positional indices."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the reducer we are using the uncontrolled "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" initializer from Foundation. Every invocation"},{"type":"text","text":" "},{"type":"text","text":"of the initializer produces a fully random UUID. That may seem like what we want, but unfortunately"},{"type":"text","text":" "},{"type":"text","text":"it wreaks havoc on our ability to test."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we tried writing a test for the add todo functionality we will quickly find that we can’t"},{"type":"text","text":" "},{"type":"text","text":"possibly predict what UUID will be produced for the new todo:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testAddTodo() async {","  let store = TestStore(","    initialState: Todos.State(), ","    reducer: Todos()","  )","","  await store.send(.addButtonTapped) {","    $0.todos = [","      Todo(id: ???)","    ]","  }","}"]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Read the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"},{"type":"text","text":" article to learn how to write tests for state mutations and effect"},{"type":"text","text":" "},{"type":"text","text":"execution in your features."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is no way to get this test to pass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is why controlling dependencies is important. It allows us to substitute a UUID generator that"},{"type":"text","text":" "},{"type":"text","text":"is deterministic in tests, such as one that simply increments by 1 every time it is invoked."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a controlled UUID generator and can be accessed by using the"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" property wrapper to add a dependency to the "},{"type":"codeVoice","code":"Todos"},{"type":"text","text":" reducer:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  @Dependency(\\.uuid) var uuid","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then when you need a new UUID you should reach for the dependency rather than reaching for the"},{"type":"text","text":" "},{"type":"text","text":"uncontrollable UUID initializer:"}]},{"type":"codeListing","syntax":"swift","code":["case .addButtonTapped:","  state.todos.append(Todo(id: self.uuid()) \/\/ ⬅️","  return .none"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you do this little bit of upfront work you instantly unlock the ability to test the feature by"},{"type":"text","text":" "},{"type":"text","text":"providing a controlled, deterministic version of the UUID generator in tests. The library even comes"},{"type":"text","text":" "},{"type":"text","text":"with such a version for the UUID generator, and it is called "},{"type":"codeVoice","code":"incrementing"},{"type":"text","text":". You can override"},{"type":"text","text":" "},{"type":"text","text":"the dependency directly on the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" so that your feature’s reducer uses that version"},{"type":"text","text":" "},{"type":"text","text":"instead of the live one:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testAddTodo() async {","  let store = TestStore(","    initialState: Todos.State(), ","    reducer: Todos()","  )","","  store.dependencies.uuid = .incrementing","","  await store.send(.addButtonTapped) {","    $0.todos = [","      Todo(id: UUID(string: \"00000000-0000-0000-0000-000000000000\")!)","    ]","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This test will pass deterministically, 100% of the time, and this is why it is so important to"},{"type":"text","text":" "},{"type":"text","text":"control dependencies that interact with outside systems."}]},{"anchor":"Using-library-dependencies","level":2,"type":"heading","text":"Using library dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with many common dependencies that can be used in a controllable manner, such as"},{"type":"text","text":" "},{"type":"text","text":"date generators, clocks, random number generators, UUID generators, and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a feature that needs access to a date initializer, the continuous"},{"type":"text","text":" "},{"type":"text","text":"clock for time-based asynchrony, and a UUID initializer. All 3 dependencies can be added to your"},{"type":"text","text":" "},{"type":"text","text":"feature’s reducer:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","  @Dependency(\\.date) var date","  @Dependency(\\.continuousClock) var clock","  @Dependency(\\.uuid) var uuid","","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, all 3 dependencies can easily be overridden with deterministic versions when testing the"},{"type":"text","text":" "},{"type":"text","text":"feature:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testTodos() async {","  let store = TestStore(","    initialState: Todos.State(),","    reducer: Todos()","  )","","  store.dependencies.date = .constant(Date(timeIntervalSinceReferenceDate: 1234567890))","  store.dependencies.continuousClock = ImmediateClock()","  store.dependencies.uuid = .incrementing","","  \/\/ ...","}"]},{"anchor":"Registering-your-own-dependencies","level":2,"type":"heading","text":"Registering your own dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Although the library comes with many controllable dependencies out of the box, there are still"},{"type":"text","text":" "},{"type":"text","text":"times when you want to register your own dependencies with the library so that you can use the"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" property wrapper. Doing this is quite similar to  registering an"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues"},{"type":"text","text":" in SwiftUI."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First you create a type that conforms to the "},{"type":"codeVoice","code":"DependencyKey"},{"type":"text","text":" protocol. The minimum implementation"},{"type":"text","text":" "},{"type":"text","text":"you must provide is a "},{"type":"codeVoice","code":"liveValue"},{"type":"text","text":", which is the value used when running the app in a simulator or"},{"type":"text","text":" "},{"type":"text","text":"on device, and so it’s appropriate for it to actually make network requests to an external server:"}]},{"type":"codeListing","syntax":"swift","code":["private enum APIClientKey: DependencyKey {","  static let liveValue = APIClient.live","}"]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two other values you can provide for a dependency. If you implement "},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" "},{"type":"text","text":"it will be used when testing features in a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":", and if you implement "},{"type":"codeVoice","code":"previewValue"},{"type":"text","text":" it"},{"type":"text","text":" "},{"type":"text","text":"will be used while running features in an Xcode preview. You don’t need to worry about those"},{"type":"text","text":" "},{"type":"text","text":"values when you are just getting started, and instead can"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"add them later"}],"isActive":true,"type":"reference","identifier":"#Live-preview-and-test-dependencies","overridingTitle":"add them later"},{"type":"text","text":"."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, an extension must be made to "},{"type":"codeVoice","code":"DependencyValues"},{"type":"text","text":" to expose a computed property for the"},{"type":"text","text":" "},{"type":"text","text":"dependency:"}]},{"type":"codeListing","syntax":"swift","code":["extension DependencyValues {","  var apiClient: APIClient {","    get { self[APIClientKey.self] }","    set { self[APIClientKey.self] = newValue }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With those few steps completed you can instantly access your API client dependency from any"},{"type":"text","text":" "},{"type":"text","text":"feature’s reducer by using the "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" property wrapper:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  @Dependency(\\.apiClient) var apiClient","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will automatically use the live dependency in previews, simulators and devices, and in"},{"type":"text","text":" "},{"type":"text","text":"tests you can override any endpoint of the dependency to return mock data:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testFetchUser() async {","  let store = TestStore(","    initialState: Todos.State(),","    reducer: Todos()","  )","","  store.dependencies.apiClient.fetchUser = { _ in User(id: 1, name: \"Blob\") }","","  await store.send(.loadButtonTapped)","  await store.receive(.userResponse(.success(User(id: 1, name: \"Blob\")))) {","    $0.loadedUser = User(id: 1, name: \"Blob\")","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Often times it is not necessary to create a whole new type to conform to "},{"type":"codeVoice","code":"DependencyKey"},{"type":"text","text":". If the"},{"type":"text","text":" "},{"type":"text","text":"dependency you are registering is a type that you own, then you can conform it directly to the"},{"type":"text","text":" "},{"type":"text","text":"protocol:"}]},{"type":"codeListing","syntax":"swift","code":["extension APIClient: DependencyKey {","  static let liveValue = APIClient.live","}","","extension DependencyValues {","  var apiClient: APIClient {","    get { self[APIClient.self] }","    set { self[APIClient.self] = newValue }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That can save a little bit of boilerplate."}]},{"anchor":"Live-preview-and-test-dependencies","level":2,"type":"heading","text":"Live, preview and test dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the previous section we showed that to conform to "},{"type":"codeVoice","code":"DependencyKey"},{"type":"text","text":" you must provide "},{"type":"emphasis","inlineContent":[{"type":"text","text":"at least"}]},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"codeVoice","code":"liveValue"},{"type":"text","text":", which is the default version of the dependency that is used when running on a"},{"type":"text","text":" "},{"type":"text","text":"device or simulator. The "},{"type":"codeVoice","code":"DependencyKey"},{"type":"text","text":" protocol inherits from a base protocol,"},{"type":"text","text":" "},{"type":"codeVoice","code":"TestDependencyKey"},{"type":"text","text":", which has 2 other requirements, "},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" and "},{"type":"codeVoice","code":"previewValue"},{"type":"text","text":". Both are"},{"type":"text","text":" "},{"type":"text","text":"optional and delegate to "},{"type":"codeVoice","code":"liveValue"},{"type":"text","text":" if not implemented."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you implement a static "},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" property on your key, that value will be used when running"},{"type":"text","text":" "},{"type":"text","text":"your feature in a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":". This is a great opportunity to supply a mocked version of the"},{"type":"text","text":" "},{"type":"text","text":"dependency that does not reach out to the real world. By doing this you can guarantee that your"},{"type":"text","text":" "},{"type":"text","text":"tests will never accidentally make a network request, or track analytics events that are not"},{"type":"text","text":" "},{"type":"text","text":"actually tied to user actions, and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, we highly recommend you consider making your "},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" dependency into what we like to"},{"type":"text","text":" "},{"type":"text","text":"call an “unimplemented” dependency. This is a version of your dependency that performs an "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" "},{"type":"text","text":"in each endpoint so that if it is ever invoked in tests it will cause a test failure. This allows"},{"type":"text","text":" "},{"type":"text","text":"you to be more explicit about what dependencies are actually needed to test a particular user"},{"type":"text","text":" "},{"type":"text","text":"flow in your feature."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have an API client with endpoints for fetching a list of users or fetching"},{"type":"text","text":" "},{"type":"text","text":"a particular user by id:"}]},{"type":"codeListing","syntax":"swift","code":["struct APIClient {","  var fetchUser: (User.ID) async throws -> User","  var fetchUsers: () async throws -> [User]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can construct an “unimplemented” version of this dependency that invokes "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" when"},{"type":"text","text":" "},{"type":"text","text":"any endpoint is invoked"}]},{"type":"codeListing","syntax":"swift","code":["extension APIClient {","  static let unimplemented = Self(","    fetchUser: { _ in XCTFail(\"APIClient.fetchUser unimplemented\") }","    fetchUsers: { XCTFail(\"APIClient.fetchUsers unimplemented\") }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" cannot be used in non-test targets, and so this instance cannot be defined"},{"type":"text","text":" "},{"type":"text","text":"in the same file where your dependency is registered. To work around this you can use our"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay"},{"type":"text","text":" library that dynamically invokes "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"it is automatically accessible when using the Composable Architecture. It also comes with some"},{"type":"text","text":" "},{"type":"text","text":"helpers to ease the construction of these unimplemented values, which we can use when defining the"},{"type":"text","text":" "},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" of your dependency:"}]},{"type":"codeListing","syntax":"swift","code":["import XCTestDynamicOverlay","","extension APIClient {","  static let testValue = Self(","    fetchUser: unimplemented(\"APIClient.fetchUser\")","    fetchUsers: unimplemented(\"APIClient.fetchUsers\")","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The other requirement of "},{"type":"codeVoice","code":"TestDependencyKey"},{"type":"text","text":" is "},{"type":"codeVoice","code":"previewValue"},{"type":"text","text":", and if this value is implemented"},{"type":"text","text":" "},{"type":"text","text":"it will be used whenever your feature is run in an Xcode preview. Previews are similar to tests in"},{"type":"text","text":" "},{"type":"text","text":"that you usually do not want to interact with the outside world, such as making network requests."},{"type":"text","text":" "},{"type":"text","text":"In fact, many of Apple’s frameworks do not work in previews, such as Core Location, and so it will"},{"type":"text","text":" "},{"type":"text","text":"be hard to interact with your feature in previews if it touches those frameworks."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, previews are dissimilar to tests in that it’s fine for dependencies to return some mock"},{"type":"text","text":" "},{"type":"text","text":"data. There’s no need to deal with “unimplemented” clients for proving which dependencies are"},{"type":"text","text":" "},{"type":"text","text":"actually used."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For the "},{"type":"codeVoice","code":"APIClient"},{"type":"text","text":" example from above, we might define its "},{"type":"codeVoice","code":"previewValue"},{"type":"text","text":" like so:"}]},{"type":"codeListing","syntax":"swift","code":["extension APIClient: TestDependencyKey {","  static let previewValue = Self(","    fetchUsers: { ","      [","        User(id: 1, name: \"Blob\"),","        User(id: 1, name: \"Blob Jr.\"),","        User(id: 1, name: \"Blob Sr.\"),","      ]","    },","    fetchUser: { id in ","      User(id: id, name: \"Blob, id: \\(id)\")","    }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then when running a feature that uses this dependency in an Xcode preview will immediately get"},{"type":"text","text":" "},{"type":"text","text":"data provided to it, making it easier for you to iterate on your feature’s logic and styling."}]},{"anchor":"Designing-dependencies","level":2,"type":"heading","text":"Designing dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Making it possible to control your dependencies is the most important step you can take towards"},{"type":"text","text":" "},{"type":"text","text":"making your features isolatable and testable. The second most important step after that is to"},{"type":"text","text":" "},{"type":"text","text":"design your dependencies in a way that maximizes their flexibility in tests and other situations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most popular way to design dependencies in Swift is to use protocols. For example, if your"},{"type":"text","text":" "},{"type":"text","text":"feature needs to interact with an audio player, you might design a protocol with methods for"},{"type":"text","text":" "},{"type":"text","text":"playing, stopping, and more:"}]},{"type":"codeListing","syntax":"swift","code":["protocol AudioPlayer {","  func loop(_ url: URL) async throws","  func play(_ url: URL) async throws ","  func setVolume(_ volume: Float) async","  func stop() async","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you are free to make as many conformances of this protocol as you want, such as a"},{"type":"text","text":" "},{"type":"codeVoice","code":"LiveAudioPlayer"},{"type":"text","text":" that actually interacts with AVFoundation, or a "},{"type":"codeVoice","code":"MockAudioPlayer"},{"type":"text","text":" that doesn’t"},{"type":"text","text":" "},{"type":"text","text":"play any sounds, but does suspend in order to simulate that something is playing. You could even"},{"type":"text","text":" "},{"type":"text","text":"have an "},{"type":"codeVoice","code":"UnimplementedAudioPlayer"},{"type":"text","text":" conformance that invokes "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" when any method is invoked."},{"type":"text","text":" "},{"type":"text","text":"And all of those conformances can be used to specify the live, preview and test values for the"},{"type":"text","text":" "},{"type":"text","text":"dependency:"}]},{"type":"codeListing","syntax":"swift","code":["private enum AudioPlayerKey: DependencyKey {","  static let liveValue: any AudioPlayer = LiveAudioPlayer()","  static let previewValue: any AudioPlayer = MockAudioPlayer()","  static let testValue: any AudioPlayer = UnimplementedAudioPlayer()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This style of dependencies works just fine, and if it is what you are most comfortable with then"},{"type":"text","text":" "},{"type":"text","text":"there is no need to change."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there is a small change one can make to this dependency to unlock even more power. Rather"},{"type":"text","text":" "},{"type":"text","text":"than designing the audio player as a protocol, we can use a struct with closure properties to"},{"type":"text","text":" "},{"type":"text","text":"represent the interface:"}]},{"type":"codeListing","syntax":"swift","code":["struct AudioPlayerClient {","  var loop: (_ url: URL) async throws -> Void","  var play: (_ url: URL) async throws -> Void","  var setVolume: (_ volume: Float) async -> Void","  var stop: () async -> Void","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, rather than defining types that conform to the protocol you construct values:"}]},{"type":"codeListing","syntax":"swift","code":["extension AudioPlayerClient {","  static let live = Self(…)","  static let mock = Self(…)","  static let unimplemented = Self(…)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And to register the dependency you can leverage the struct that defines the interface. There’s no"},{"type":"text","text":" "},{"type":"text","text":"need to define a new type:"}]},{"type":"codeListing","syntax":"swift","code":["extension AudioPlayerClient: DependencyKey {","  static let liveValue = AudioPlayerClient.live","  static let previewValue = AudioPlayerClient.mock","  static let testValue = AudioPlayerClient.unimplemented","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you design your dependencies in this way you can pick which dependency endpoints you need in your"},{"type":"text","text":" "},{"type":"text","text":"feature. For example, if you have a feature that needs an audio player to do its job, but it only"},{"type":"text","text":" "},{"type":"text","text":"needs the "},{"type":"codeVoice","code":"play"},{"type":"text","text":" endpoint, and doesn’t need to loop, set volume or stop audio, then you can specify"},{"type":"text","text":" "},{"type":"text","text":"a dependency on just that one function:"}]},{"type":"codeListing","syntax":"swift","code":["struct Feature: ReducerProtocol {","  @Dependency(\\.audioPlayer.play) var play","  \/\/ …","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can allow your features to better describe the minimal interface they need from dependencies,"},{"type":"text","text":" "},{"type":"text","text":"which can help a feature to seem less intimidating."}]},{"anchor":"Overriding-dependencies","level":2,"type":"heading","text":"Overriding dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is possible to change the dependencies for just one particular reducer inside a larger composed"},{"type":"text","text":" "},{"type":"text","text":"reducer. This can be handy when running a feature in a more controlled environment where it may not be"},{"type":"text","text":" "},{"type":"text","text":"appropriate to communicate with the outside world."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you want to teach users how to use your feature through an onboarding"},{"type":"text","text":" "},{"type":"text","text":"experience. In such an experience it may not be appropriate for the user’s actions to cause"},{"type":"text","text":" "},{"type":"text","text":"data to be written to disk, or user defaults to be written, or any number of things. It would be"},{"type":"text","text":" "},{"type":"text","text":"better to use mock versions of those dependencies so that the user can interact with your feature"},{"type":"text","text":" "},{"type":"text","text":"in a fully controlled environment."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To do this you can use the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/dependency(_:_:)"},{"type":"text","text":" method to override a reducer’s"},{"type":"text","text":" "},{"type":"text","text":"dependency with another value:"}]},{"type":"codeListing","syntax":"swift","code":["struct Onboarding: ReducerProtocol {","  var body: some ReducerProtocol<State, Action> {","    Reduce { state, action in ","      \/\/ Additional onboarding logic","    }","    Feature()","      .dependency(\\.userDefaults, .mock)","      .dependency(\\.database, .mock)","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will cause the "},{"type":"codeVoice","code":"Feature"},{"type":"text","text":" reducer to use a mock user defaults and database dependency, as well"},{"type":"text","text":" "},{"type":"text","text":"as any reducer "},{"type":"codeVoice","code":"Feature"},{"type":"text","text":" uses under the hood, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" any effects produced by "},{"type":"codeVoice","code":"Feature"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/dependencymanagement"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to register dependencies with the library so that they can be immediately accessible from"},{"type":"text","text":" "},{"type":"text","text":"any reducer."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Dependencies","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance"],"generated":true}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"role":"symbol","title":"TestStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStore"}],"abstract":[{"type":"text","text":"A testable runtime for a reducer."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TestStore"}],"url":"\/documentation\/composablearchitecture\/teststore"},"https://github.com/pointfreeco/swift-identified-collections":{"title":"Identified Collections","titleInlineContent":[{"type":"text","text":"Identified Collections"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections","url":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"},"http://github.com/pointfreeco/xctest-dynamic-overlay":{"title":"XCTestDynamicOverlay","titleInlineContent":[{"type":"text","text":"XCTestDynamicOverlay"}],"type":"link","identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay","url":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay"},"https://developer.apple.com/documentation/swiftui/environmentvalues":{"title":"environment value","titleInlineContent":[{"type":"text","text":"environment value"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues","url":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"role":"article","title":"Performance","abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/performance"},"#Overriding-dependencies":{"title":"Overriding dependencies","titleInlineContent":[{"type":"text","text":"Overriding dependencies"}],"type":"link","identifier":"#Overriding-dependencies","url":"#Overriding-dependencies"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/dependency(_:_:)":{"role":"symbol","title":"dependency(_:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"dependency"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"WritableKeyPath","preciseIdentifier":"s:s15WritableKeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"DependencyValues","preciseIdentifier":"s:12Dependencies16DependencyValuesV"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"_DependencyKeyWritingReducer"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Sets the dependency value of the specified key path to the given value."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/dependency(_:_:)","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/reducerprotocol\/dependency(_:_:)"},"#Designing-dependencies":{"title":"Designing dependencies","titleInlineContent":[{"type":"text","text":"Designing dependencies"}],"type":"link","identifier":"#Designing-dependencies","url":"#Designing-dependencies"},"#Using-library-dependencies":{"title":"Using library dependencies","titleInlineContent":[{"type":"text","text":"Using library dependencies"}],"type":"link","identifier":"#Using-library-dependencies","url":"#Using-library-dependencies"},"#The-need-for-controlled-dependencies":{"title":"The need for controlled dependencies","titleInlineContent":[{"type":"text","text":"The need for controlled dependencies"}],"type":"link","identifier":"#The-need-for-controlled-dependencies","url":"#The-need-for-controlled-dependencies"},"#Registering-your-own-dependencies":{"title":"Registering your own dependencies","titleInlineContent":[{"type":"text","text":"Registering your own dependencies"}],"type":"link","identifier":"#Registering-your-own-dependencies","url":"#Registering-your-own-dependencies"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/testing"},"#Live-preview-and-test-dependencies":{"title":"Live, preview and test dependencies","titleInlineContent":[{"type":"text","text":"Live, preview and test dependencies"}],"type":"link","identifier":"#Live-preview-and-test-dependencies","url":"#Live-preview-and-test-dependencies"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"role":"article","title":"Getting started","abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingstarted"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"}}}