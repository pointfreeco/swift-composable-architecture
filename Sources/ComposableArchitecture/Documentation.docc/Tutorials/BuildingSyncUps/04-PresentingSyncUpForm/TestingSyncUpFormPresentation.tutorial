@Tutorial(time: 10) {
  @Intro(title: "Testing the add sync-up flow") {
    We have now integrated two moderately complex features, the `SyncUpsList` and `SyncUpForm`, and
    so its time to write some tests. This will give us the opportunity to prove that the features
    work in tandem as we expect, and we will explore "non-exhaustive" testing to make our tests less
    fragile.
  }
  
  @Section(title: "Adding a sync-up") {
    @ContentAndMedia {
      Let's start by testing the flow of adding a sync-up.
    }
    
    @Steps {
      @Step {
        These new tests will go in the SyncUpsListTests.swift file since we are testing the 
        integration of the list feature with the form feature. We already have one, very simple test
        in this file for the deletion logic (code is currently omitted from the snippet). Add a new
        test method for the flow of adding a sync-up.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0001.swift, previousFile: TestingSyncUpFormPresentation-01-code-0001-previous.swift)
      }
      
      @Step {
        As with every test in the Composable Architecture, we start by creating a 
        ``ComposableArchitecture/TestStore`` for the feature we are testing. We will start the 
        feature in a state with no sync-ups.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0002.swift)
      }
      
      @Step {
        Emulate the user tapping on the "+" button in the top-right of the interface by sending the
        `addSyncUpButtonTapped` action. When that action is sent we expect the `addSyncUp` state to
        be populated, representing that the sheet should appear.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0003.swift)
      }
      
      @Step {
        Run the test to see that unfortunately it fails.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0004.swift)
      }
      
      The problem is similar to what we encountered while writing tests for the `SyncUpForm`
      feature. We are using an uncontrolled dependency in the `SyncUpsList` feature for generating 
      UUIDs. We now need to control that dependency.
      
      @Step {
        Go to SyncUpsList.swift and add a dependency on the UUID generator.
        
        @Code(name: "SyncUpsList.swift", file: TestingSyncUpFormPresentation-01-code-0005.swift, previousFile: TestingSyncUpFormPresentation-01-code-0005-previous.swift)
      }
      
      @Step {
        Use the controlled UUID generator rather than reaching out the global, uncontrolled UUID 
        initializer.
        
        @Code(name: "SyncUpsList.swift", file: TestingSyncUpFormPresentation-01-code-0006.swift)
      }
      
      @Step {
        Go back to SyncUpsListTests.swift and override the `uuid` dependency to be `.incrementing`.
        This way we can predict what UUIDs will be generated by the feature in tests.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0007.swift, previousFile: TestingSyncUpFormPresentation-01-code-0007-previous.swift)
      }
      
      Now we can predict what UUIDs will be generated in the feature. The first time a UUID is 
      created it will be 00000000-0000-0000-0000-000000000000. Then the next time it will be 
      00000000-0000-0000-0000-000000000001. And on, and on, and onâ€¦
      
      @Step {
        Update the assertion to confirm that the newly created `SyncUp` should have an ID that is 
        the UUID with all 0s.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0008.swift)
      }
      
      Now the test passes with flying colors!
      
      But we also haven't tested too much yet. We've just confirmed that when the user taps the "+"
      that some state in the feature is populated. Let's now emulate the user making some changes to
      the sync-up in the form, and then confirming the addition of the sync-up to the root list.
      
      @Step {
        Emulate the user editing some details of the sync-up. To do this we need to send an action
        in the sync-up form's domain, which can be done by sending a nested enum action that 
        represents an action in the `addSyncUp` domain.
        
        > Note: We are using key path syntax to describe the nested action to send. 
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0009.swift)
      }
      
      @Step {
        Inside the `.addSyncUp` case we can send any action in the `SyncUpForm` domain. In 
        particular we know that the `SyncUpForm` has a ``ComposableArchitecture/BindingAction``
        that was used to bind the `syncUp` to various UI controls in the view. We can send a binding
        action by chaining onto ``ComposableArchitecture/BindableAction/binding(_:)``:
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0010.swift)
      }
      
      @Step {
        Inside the `.binding` case we can further chain onto any field in the feature's state
        to update it. Construct a new `SyncUp` that represents the edits that are made by the user,
        and assert on how we expect the state to change.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0011.swift)
      }
      
      Run the test to see that it passes!
      
      We have now emulated the user opening the "Add sync-up" sheet and making some edits to the 
      sync-up. Let's tie the knot by now emulating the user confirming to add the sync-up to the 
      root list.
      
      @Step {
        Emulate the user tapping on the "Add" button in the sheet.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0012.swift)
      }
      
      @Step {
        Run the test to see that we get a failure.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0013.swift)
      }
      
      This is happening because when the addition of the sync-up is confirmed, the root
      `SyncUpsList` feature mutates its state to add the sync-up, and it clears out the `addSyncUp`
      state in order to dismiss the sheet. The ``ComposableArchitecture/TestStore`` forces us to
      assert on _everything_ happening in the feature so that if someday we accidentally remove
      that dismissal logic we will instantly get a test failure.
      
      Let's now assert on that logic.
      
      @Step {
        Assert that after the `confirmAddButtonTapped` is sent that the root `SyncUpsList` feature
        has updated its `syncUps` array to have the newly edited sync-up, and it `nil`'s out the
        `addSyncUp` state to represent dismissal of the sheet.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-01-code-0014.swift)
      }
      
      We now have a passing test, and it exercises the integration of two features. We have emulated
      the full flow of a user bringing up the "New sync-up" sheet, making some changes, tapping
      "Add", and proved that the new sheet was added to the list and the sheet was dismissed. As
      long as we have hooked everything up in the view properly, and as long as we trust SwiftUI to
      do its  job, we can be confident this feature works the way we expect.
    }
  }
  
  @Section(title: "Non-exhaustive testing") {
    @ContentAndMedia {
      The test we wrote in the previous section is incredibly powerful, but also a bit verbose. As
      the features you test get more complex, and as you test the integration of more features, you
      may come to a point where you do not want to exhaustively assert on every little thing
      happening inside the features.
      
      This is where non-exhaustive testing is helpful. It allows you to write tests in the same
      style as before, but you can choose what state you want to assert on, and you can ignore state
      that is not interesting to you.
      
      Typically you will have a mixture of exhaustive and non-exhaustive tests in your suite.
      Exhaustive tests are a great default for testing leaf features, but every once in a while you
      may want an exhaustive test on feature integrations. And then non-exhaustive tests are a great
      default for testing the integration of features, and may make sense every once in a while on
      leaf features.
    }
    
    @Steps {
      @Step {
        Add a new test method for testing the "Add sync-up" flow, but this time in an exhaustive 
        manner.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-02-code-0001.swift, previousFile: TestingSyncUpFormPresentation-02-code-0001-previous.swift)
      }
      
      @Step {
        Create a ``ComposableArchitecture/TestStore`` just like we did before, but this time we 
        will set the store's ``ComposableArchitecture/TestStore/exhaustivity`` to `.off`. This
        puts the test store in "non-exhaustive" mode.
        
        > Note: The default value of ``ComposableArchitecture/TestStore/exhaustivity`` is `.on` and
        > so typically it does not need to be set.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-02-code-0002.swift)
      }
      
      @Step {
        Emulate the user tapping the "+" button in the UI by sending the `.addSyncUpButtonTapped`
        action.
        
        Run the test to see that it passes.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-02-code-0003.swift)
      }
      
      Already we can see a difference between non-exhaustive and exhaustive test stores. We are not
      specifying the trailing closure in
      ``ComposableArchitecture/TestStore/send(_:assert:file:line:)-2co21`` to assert on state
      changes, yet the test will still pass.
      
      A non-exhaustive store operates similarly to an exhaustive one, but with a few key 
      differences. In a non-exhaustive store, the `$0` handed to the trailing closure of
      ``ComposableArchitecture/TestStore/send(_:assert:file:line:)-2co21`` is the state _after_
      the action has been processed, whereas in an exhaustive test store it is the state _before_.
      This means in non-exhaustive test stores you do not have make any mutations in the trailing
      closure if you do not want to. And anything you _do_ set in the trailing closure must match
      what was already there in order for the test to pass. See the dedicated article 
      <doc:Testing#Non-exhaustive-testing> for more information.
      
      @Step {
        Emulate the user making edits to the sync-up, but again do not provide a trailing closure.
        We will not assert on how the state changes for this action. 
        
        Run the test to see that it passes.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-02-code-0004.swift)
      }
      
      @Step {
        Emulate the user tapping the "Add" button to confirm adding the sync-up. This time we will
        provide an assertion trailing closure, but we will only assert that the edited sync-up was
        added to the root list.
        
        Run the test to see that it passes.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-02-code-0005.swift)
      }
      
      This test passes, and it proves at a very high level that when the user does the full "Add
      sync-up" flow that a sync-up is added to the root list without asserting on every little
      detail long the way.
      
      There is an alternate non-exhaustive mode called 
      ``ComposableArchitecture/Exhaustivity/off(showSkippedAssertions:)``. The 
      `showSkippedAssertions` flag allows you to see what state you did not assert on without 
      failing the test suite. The default value is `false`, but it can be turned on explicitly.
      
      @Step {
        Put the test store in the alternate non-exhaustive mode.
        
        Run the test to see that it passes, but that for any state we did not assert on we get a 
        grey informational box in Xcode letting us know what was skipped.
        
        @Code(name: "SyncUpsListTests.swift", file: TestingSyncUpFormPresentation-02-code-0006.swift)
      }
      
      This mode of non-exhaustive testing can be great for debugging. Non-exhaustive testing has
      the downside that you can have a passing test that is secretly hiding a production bug since
      you are not asserting on _everything_. 
      
      If you are seeing a mysterious bug in the simulator or device that you have test coverage for,
      then you can turn on `showSkippedAssertions` to get a view into what state you are not 
      asserting on and search for the bug there.
    }
  }
}
