{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As your features and application grow you may run into performance problems, such as reducers"},{"type":"text","text":" "},{"type":"text","text":"becoming slow to execute, SwiftUI view bodies executing more often than expected, and more."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#View-stores"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#CPU-intensive-calculations"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#High-frequency-actions"}]}]}]},{"anchor":"View-stores","level":3,"type":"heading","text":"View stores"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A common performance pitfall when using the library comes from constructing "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore"},{"type":"text","text":"s. When"},{"type":"text","text":" "},{"type":"text","text":"constructed naively, using either view store’s initializer "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore\/init(_:)-1pfeq"},{"type":"text","text":" or the"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI helper "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore"},{"type":"text","text":", it will observe every change to state in the store:"}]},{"type":"codeListing","syntax":"swift","code":["WithViewStore(self.store, observe: { $0 }) { viewStore in ","  \/\/ This is executed for every action sent into the system ","  \/\/ that causes self.store.state to change. ","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most of the time this observes far too much state. A typical feature in the Composable Architecture"},{"type":"text","text":" "},{"type":"text","text":"holds onto not only the state the view needs to present UI, but also state that the feature only"},{"type":"text","text":" "},{"type":"text","text":"needs internally, as well as state of child features embedded in the feature. Changes to the"},{"type":"text","text":" "},{"type":"text","text":"internal and child state should not cause the view’s body to re-compute since that state is not"},{"type":"text","text":" "},{"type":"text","text":"needed in the view."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if the root of our application was a tab view, then we could model that in state as a"},{"type":"text","text":" "},{"type":"text","text":"struct that holds each tab’s state as a property:"}]},{"type":"codeListing","syntax":"swift","code":["struct AppState {","  var activity: ActivityState","  var search: SearchState","  var profile: ProfileState","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the view only needs to construct the views for each tab, then no view store is even needed"},{"type":"text","text":" "},{"type":"text","text":"because we can pass scoped stores to each child feature view:"}]},{"type":"codeListing","syntax":"swift","code":["struct AppView: View {","  let store: Store<AppState, AppAction>","","  var body: some View {","    \/\/ No need to observe state changes because the view does","    \/\/ not need access to the state.","","    TabView {","      ActivityView(","        store: self.store","          .scope(state: \\.activity, action: AppAction.activity)","      )","      SearchView(","        store: self.store","          .scope(state: \\.search, action: AppAction.search)","      )","      ProfileView(","        store: self.store","          .scope(state: \\.profile, action: AppAction.profile)","      )","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This means "},{"type":"codeVoice","code":"AppView"},{"type":"text","text":" does not actually need to observe any state changes. This view will only be"},{"type":"text","text":" "},{"type":"text","text":"created a single time, whereas if we observed the store then it would re-compute every time a single"},{"type":"text","text":" "},{"type":"text","text":"thing changed in either the activity, search or profile child features."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If sometime in the future we do actually need some state from the store, we can create a localized"},{"type":"text","text":" "},{"type":"text","text":"“view state” struct that holds only the bare essentials of state that the view needs to do its"},{"type":"text","text":" "},{"type":"text","text":"job. For example, suppose the activity state holds an integer that represents the number of"},{"type":"text","text":" "},{"type":"text","text":"unread activities. Then we could observe changes to only that piece of state like so:"}]},{"type":"codeListing","syntax":"swift","code":["struct AppView: View {","  let store: Store<AppState, AppAction>","  ","  struct ViewState {","    let unreadActivityCount: Int","    init(state: AppState) {","      self.unreadActivityCount = state.activity.unreadCount","    }","  }","","  var body: some View {","    WithViewStore(self.store, observe: ViewState.init) { viewStore in ","      TabView {","        ActivityView(","          store: self.store","            .scope(state: \\.activity, action: AppAction.activity","        )","        .badge(\"\\(viewStore.unreadActivityCount)\")","","        \/\/ ...","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the "},{"type":"codeVoice","code":"AppView"},{"type":"text","text":" will re-compute its body only when "},{"type":"codeVoice","code":"activity.unreadCount"},{"type":"text","text":" changes. In particular,"},{"type":"text","text":" "},{"type":"text","text":"no changes to the search or profile features will cause the view to re-compute, and that greatly"},{"type":"text","text":" "},{"type":"text","text":"reduces how often the view must re-compute."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This technique for reducing view re-computations is most effective towards the root of your app"},{"type":"text","text":" "},{"type":"text","text":"hierarchy and least effective towards the leaf nodes of your app. Root features tend to hold lots"},{"type":"text","text":" "},{"type":"text","text":"of state that its view does not need, such as child features, and leaf features tend to only hold"},{"type":"text","text":" "},{"type":"text","text":"what’s necessary. If you are going to employ this technique you will get the most benefit by"},{"type":"text","text":" "},{"type":"text","text":"applying it to views closer to the root."}]},{"anchor":"CPU-intensive-calculations","level":3,"type":"heading","text":"CPU intensive calculations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reducers are run on the main thread and so they are not appropriate for performing intense CPU"},{"type":"text","text":" "},{"type":"text","text":"work. If you need to perform lots of CPU-bound work, then it is more appropriate to use an"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":", which will operate in the cooperative thread pool, and then send it’s output back into"},{"type":"text","text":" "},{"type":"text","text":"the system via an action. You should also make sure to perform your CPU intensive work in a"},{"type":"text","text":" "},{"type":"text","text":"cooperative manner by periodically suspending with "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" so that you do not block a thread"},{"type":"text","text":" "},{"type":"text","text":"in the cooperative pool for too long."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, instead of performing intense work like this in your reducer:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  var result = \/\/ ...","  for value in someLargeCollection {","    \/\/ Some intense computation with value","  }","  state.result = result"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"…you should return an effect to perform that work, sprinkling in some yields every once in awhile,"},{"type":"text","text":" "},{"type":"text","text":"and then delivering the result in an action:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  return .task {","    var result = \/\/ ...","    for (index, value) in someLargeCollection.enumerated() {","      \/\/ Some intense computation with value","","      \/\/ Yield every once in awhile to cooperate in the thread pool.","      if index.isMultiple(of: 1_000) {","        await Task.yield()","      }","    }","    return .response(result)","  }","","case let .response(result):","  state.result = result"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will keep CPU intense work from being performed in the reducer, and hence not on the main"},{"type":"text","text":" "},{"type":"text","text":"thread."}]},{"anchor":"High-frequency-actions","level":3,"type":"heading","text":"High-frequency actions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sending actions in a Composable Architecture application should not be thought as simple method"},{"type":"text","text":" "},{"type":"text","text":"calls that one does with classes, such as "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" conformances. When an action is sent"},{"type":"text","text":" "},{"type":"text","text":"into the system there are multiple layers of features that can intercept and interpret it, and"},{"type":"text","text":" "},{"type":"text","text":"the resulting state changes can reverberate throughout the entire application."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of this, sending actions do come with a cost. You should aim to only send “significant”"},{"type":"text","text":" "},{"type":"text","text":"actions into the system, that is, actions that cause the execution of important logic and effects"},{"type":"text","text":" "},{"type":"text","text":"for your application. High-frequency actions, such as sending dozens of actions per second,"},{"type":"text","text":" "},{"type":"text","text":"should be avoided unless your application truly needs that volume of actions in order to implement"},{"type":"text","text":" "},{"type":"text","text":"its logic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there are often times that actions are sent at a high frequency but the reducer doesn’t"},{"type":"text","text":" "},{"type":"text","text":"actually need that volume of information. For example, say you were constructing an effect that"},{"type":"text","text":" "},{"type":"text","text":"wanted to report its progress back to the system for each step of its work. You could choose to send"},{"type":"text","text":" "},{"type":"text","text":"the progress for literally every step:"}]},{"type":"codeListing","syntax":"swift","code":["case .startButtonTapped:","  return .run { send in","    var count = 0","    let max = await environment.eventCount()","","    for await event in environment.eventSource() {","      defer { count += 1 }","      send(.progress(Double(count) \/ Double(max)))","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, what if the effect required 10,000 steps to finish? Or 100,000? Or more? It would be"},{"type":"text","text":" "},{"type":"text","text":"immensely wasteful to send 100,000 actions into the system to report a progress value that is only"},{"type":"text","text":" "},{"type":"text","text":"going to vary from 0.0 to 1.0."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead, you can choose to report the progress every once in awhile. You can even do the math"},{"type":"text","text":" "},{"type":"text","text":"to make it so that you report the progress at most 100 times:"}]},{"type":"codeListing","syntax":"swift","code":["case .startButtonTapped:","  return .run { send in","    var count = 0","    let max = await environment.eventCount()","    let interval = max \/ 100","","    for await event in environment.eventSource() {","      defer { count += 1 }","      if count.isMultiple(of: interval) {","        send(.progress(Double(count) \/ Double(max)))","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This greatly reduces the bandwidth of actions being sent into the system so that you are not"},{"type":"text","text":" "},{"type":"text","text":"incurring unnecessary costs for sending actions."}]},{"anchor":"Compiler-performance","level":3,"type":"heading","text":"Compiler performance"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In very large SwiftUI applications you may experience degraded compiler performance causing long"},{"type":"text","text":" "},{"type":"text","text":"compile times, and possibly even compiler failures due to “complex expressions.” The"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore"},{"type":"text","text":"  helpers that comes with the library can exacerbate that problem for very complex"},{"type":"text","text":" "},{"type":"text","text":"views. If you are running into issues using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore"},{"type":"text","text":" you can make a small change to your"},{"type":"text","text":" "},{"type":"text","text":"view to use an "},{"type":"codeVoice","code":"@ObservedObject"},{"type":"text","text":" directly."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if your view looks like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct FeatureView: View {","  let store: Store<FeatureState, FeatureAction>","","  var body: some View {","    WithViewStore(self.store, observe: { $0 }) { viewStore in","      \/\/ A large, complex view inside here...","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"…and you start running into compiler troubles, then you can refactor to the following:"}]},{"type":"codeListing","syntax":"swift","code":["struct FeatureView: View {","  let store: Store<FeatureState, FeatureAction>","  @ObservedObject var viewStore: ViewStore<FeatureState, FeatureAction>","","  init(store: Store<FeatureState, FeatureAction>) {","    self.store = store","    self.viewStore = ViewStore(self.store))","  }","","  var body: some View {","    \/\/ A large, complex view inside here...","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That should greatly improve the compiler’s ability to type-check your view."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/performance"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Performance","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingReadyForSwiftConcurrency","doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"],"generated":true}],"references":{"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/testing"},"#View-stores":{"title":"View stores","titleInlineContent":[{"type":"text","text":"View stores"}],"type":"link","identifier":"#View-stores","url":"#View-stores"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"role":"symbol","title":"Effect","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"abstract":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":" type encapsulates a unit of work that can be run in the outside world, and can"},{"type":"text","text":" "},{"type":"text","text":"feed data back to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"type":"text","text":". It is the perfect place to do side effects, such as network"},{"type":"text","text":" "},{"type":"text","text":"requests, saving\/loading from disk, creating timers, interacting with dependencies, and more."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Effect"}],"url":"\/documentation\/composablearchitecture\/effect"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/GettingReadyForSwiftConcurrency":{"role":"article","title":"Getting ready for Swift concurrency","abstract":[{"type":"text","text":"Learn how to write safe, concurrent effects using Swift’s structured concurrency."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingReadyForSwiftConcurrency","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingreadyforswiftconcurrency"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/WithViewStore":{"role":"symbol","title":"WithViewStore","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WithViewStore"}],"abstract":[{"type":"text","text":"A view helper that transforms a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"type":"text","text":" into a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore"},{"type":"text","text":" so that its state can be observed"},{"type":"text","text":" "},{"type":"text","text":"by a view builder."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WithViewStore"}],"url":"\/documentation\/composablearchitecture\/withviewstore"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"role":"article","title":"Getting started","abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingstarted"},"#High-frequency-actions":{"title":"High-frequency actions","titleInlineContent":[{"type":"text","text":"High-frequency actions"}],"type":"link","identifier":"#High-frequency-actions","url":"#High-frequency-actions"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/ViewStore/init(_:)-1pfeq":{"conformance":{"constraints":[{"type":"codeVoice","code":"State"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Store","preciseIdentifier":"s:22ComposableArchitecture5StoreC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State","preciseIdentifier":"s:22ComposableArchitecture9ViewStoreCAASQRzrlE5Statexmfp"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Action","preciseIdentifier":"s:22ComposableArchitecture9ViewStoreCAASQRzrlE6Actionq_mfp"},{"kind":"text","text":">)"}],"abstract":[],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore\/init(_:)-1pfeq","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/viewstore\/init(_:)-1pfeq"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/ViewStore":{"role":"symbol","title":"ViewStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ViewStore"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ViewStore"},{"type":"text","text":" is an object that can observe state changes and send actions. They are most"},{"type":"text","text":" "},{"type":"text","text":"commonly used in views, such as SwiftUI views, UIView or UIViewController, but they can be used"},{"type":"text","text":" "},{"type":"text","text":"anywhere it makes sense to observe state or send actions."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ViewStore"}],"url":"\/documentation\/composablearchitecture\/viewstore"},"#CPU-intensive-calculations":{"title":"CPU-intensive calculations","titleInlineContent":[{"type":"text","text":"CPU-intensive calculations"}],"type":"link","identifier":"#CPU-intensive-calculations","url":"#CPU-intensive-calculations"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture/Store":{"role":"symbol","title":"Store","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"abstract":[{"type":"text","text":"A store represents the runtime that powers the application. It is the object that you will pass"},{"type":"text","text":" "},{"type":"text","text":"around to views that need to interact with the application."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/composablearchitecture\/store"},"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"}}}