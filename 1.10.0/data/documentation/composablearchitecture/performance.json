{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As your features and application grow you may run into performance problems, such as reducers"},{"type":"text","text":" "},{"type":"text","text":"becoming slow to execute, SwiftUI view bodies executing more often than expected, and more. This"},{"type":"text","text":" "},{"type":"text","text":"article outlines a few common pitfalls when developing features in the library, and how to fix"},{"type":"text","text":" "},{"type":"text","text":"them."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Sharing-logic-with-actions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#CPU-intensive-calculations"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#High-frequency-actions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Store-scoping"}]}]}]},{"anchor":"Sharing-logic-with-actions","level":3,"type":"heading","text":"Sharing logic with actions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is a common pattern of using actions to share logic across multiple parts of a reducer."},{"type":"text","text":" "},{"type":"text","text":"This is an inefficient way to share logic. Sending actions is not as lightweight of an operation"},{"type":"text","text":" "},{"type":"text","text":"as, say, calling a method on a class. Actions travel through multiple layers of an application, and"},{"type":"text","text":" "},{"type":"text","text":"at each layer a reducer can intercept and reinterpret the action."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is far better to share logic via simple methods on your "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":" conformance."},{"type":"text","text":" "},{"type":"text","text":"The helper methods can take "},{"type":"codeVoice","code":"inout State"},{"type":"text","text":" as an argument if it needs to make mutations, and it"},{"type":"text","text":" "},{"type":"text","text":"can return an "},{"type":"codeVoice","code":"Effect<Action>"},{"type":"text","text":". This allows you to share logic without incurring the cost"},{"type":"text","text":" "},{"type":"text","text":"of sending needless actions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose that there are 3 UI components in your feature such that when any is changed"},{"type":"text","text":" "},{"type":"text","text":"you want to update the corresponding field of state, but then you also want to make some mutations"},{"type":"text","text":" "},{"type":"text","text":"and execute an effect. That common mutation and effect could be put into its own action and then"},{"type":"text","text":" "},{"type":"text","text":"each user action can return an effect that immediately emits that shared action:"}]},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct Feature {","  @ObservableState","  struct State { \/* ... *\/ }","  enum Action { \/* ... *\/ }","","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .buttonTapped:","        state.count += 1","        return .send(.sharedComputation)","","      case .toggleChanged:","        state.isEnabled.toggle()","        return .send(.sharedComputation)","","      case let .textFieldChanged(text):","        state.description = text","        return .send(.sharedComputation)","","      case .sharedComputation:","        \/\/ Some shared work to compute something.","        return .run { send in","          \/\/ A shared effect to compute something","        }","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is one way of sharing the logic and effect, but we are now incurring the cost of two actions"},{"type":"text","text":" "},{"type":"text","text":"even though the user performed a single action. That is not going to be as efficient as it would"},{"type":"text","text":" "},{"type":"text","text":"be if only a single action was sent."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Besides just performance concerns, there are two other reasons why you should not follow this"},{"type":"text","text":" "},{"type":"text","text":"pattern. First, this style of sharing logic is not very flexible. Because the shared logic is"},{"type":"text","text":" "},{"type":"text","text":"relegated to a separate action it must always be run after the initial logic. But what if"},{"type":"text","text":" "},{"type":"text","text":"instead you need to run some shared logic "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"type":"text","text":" the core logic? This style cannot accommodate that."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Second, this style of sharing logic also muddies tests. When you send a user action you have to"},{"type":"text","text":" "},{"type":"text","text":"further assert on receiving the shared action and assert on how state changed. This bloats tests"},{"type":"text","text":" "},{"type":"text","text":"with unnecessary internal details, and the test no longer reads as a script from top-to-bottom of"},{"type":"text","text":" "},{"type":"text","text":"actions the user is taking in the feature:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(initialState: Feature.State()) {","  Feature()","}","","store.send(.buttonTapped) {","  $0.count = 1","}","store.receive(\\.sharedComputation) {","  \/\/ Assert on shared logic","}","store.send(.toggleChanged) {","  $0.isEnabled = true","}","store.receive(\\.sharedComputation) {","  \/\/ Assert on shared logic","}","store.send(.textFieldChanged(\"Hello\") {","  $0.description = \"Hello\"","}","store.receive(\\.sharedComputation) {","  \/\/ Assert on shared logic","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, we do not recommend sharing logic in a reducer by having dedicated actions for the logic"},{"type":"text","text":" "},{"type":"text","text":"and executing synchronous effects."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead, we recommend sharing logic with methods defined in your feature’s reducer. The method has"},{"type":"text","text":" "},{"type":"text","text":"full access to all dependencies, it can take an "},{"type":"codeVoice","code":"inout State"},{"type":"text","text":" if it needs to make mutations to"},{"type":"text","text":" "},{"type":"text","text":"state, and it can return an "},{"type":"codeVoice","code":"Effect<Action>"},{"type":"text","text":" if it needs to execute effects."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The above example can be refactored like so:"}]},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct Feature {","  @ObservableState","  struct State { \/* ... *\/ }","  enum Action { \/* ... *\/ }","","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .buttonTapped:","        state.count += 1","        return self.sharedComputation(state: &state)","","      case .toggleChanged:","        state.isEnabled.toggle()","        return self.sharedComputation(state: &state)","","      case let .textFieldChanged(text):","        state.description = text","        return self.sharedComputation(state: &state)","      }","    }","  }","","  func sharedComputation(state: inout State) -> Effect<Action> {","    \/\/ Some shared work to compute something.","    return .run { send in","      \/\/ A shared effect to compute something","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This effectively works the same as before, but now when a user action is sent all logic is executed"},{"type":"text","text":" "},{"type":"text","text":"at once without sending an additional action. This also fixes the other problems we mentioned above."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if you need to execute the shared logic "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"type":"text","text":" the core logic, you can do so easily:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  let sharedEffect = self.sharedComputation(state: &state)","  state.count += 1","  return sharedEffect"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You have complete flexibility to decide how, when and where you want to execute the shared logic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, tests become more streamlined since you do not have to assert on internal details of"},{"type":"text","text":" "},{"type":"text","text":"shared actions being sent around. The test reads  like a user script of what the user is doing"},{"type":"text","text":" "},{"type":"text","text":"in the feature:"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(initialState: Feature.State()) {","  Feature()","}","","store.send(.buttonTapped) {","  $0.count = 1","  \/\/ Assert on shared logic","}","store.send(.toggleChanged) {","  $0.isEnabled = true","  \/\/ Assert on shared logic","}","store.send(.textFieldChanged(\"Hello\") {","  $0.description = \"Hello\"","  \/\/ Assert on shared logic","}"]},{"anchor":"Sharing-logic-in-child-features","level":5,"type":"heading","text":"Sharing logic in child features"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is another common scenario for sharing logic in features where the parent feature wants to"},{"type":"text","text":" "},{"type":"text","text":"invoke logic in a child feature. One can technically do this by sending actions from the parent"},{"type":"text","text":" "},{"type":"text","text":"to the child, but we do not recommend it (see above in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance#Sharing-logic-with-actions"},{"type":"text","text":" "},{"type":"text","text":"to learn why):"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Handling action from parent feature:","case .buttonTapped:","  \/\/ Send action to child to perform logic:","  return .send(.child(.refresh))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead, we recommend invoking the child reducer directly:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  return Child().reduce(into: &state.child, action: .refresh)","    .map(Action.child)"]},{"anchor":"CPU-intensive-calculations","level":3,"type":"heading","text":"CPU intensive calculations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reducers are run on the main thread and so they are not appropriate for performing intense CPU"},{"type":"text","text":" "},{"type":"text","text":"work. If you need to perform lots of CPU-bound work, then it is more appropriate to use an"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":", which will operate in the cooperative thread pool, and then send actions back into"},{"type":"text","text":" "},{"type":"text","text":"the system. You should also make sure to perform your CPU intensive work in a cooperative manner by"},{"type":"text","text":" "},{"type":"text","text":"periodically suspending with "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" so that you do not block a thread in the cooperative"},{"type":"text","text":" "},{"type":"text","text":"pool for too long."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, instead of performing intense work like this in your reducer:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  var result = \/\/ ...","  for value in someLargeCollection {","    \/\/ Some intense computation with value","  }","  state.result = result"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"…you should return an effect to perform that work, sprinkling in some yields every once in awhile,"},{"type":"text","text":" "},{"type":"text","text":"and then delivering the result in an action:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  return .run { send in","    var result = \/\/ ...","    for (index, value) in someLargeCollection.enumerated() {","      \/\/ Some intense computation with value","","      \/\/ Yield every once in awhile to cooperate in the thread pool.","      if index.isMultiple(of: 1_000) {","        await Task.yield()","      }","    }","    await send(.computationResponse(result))","  }","","case let .computationResponse(result):","  state.result = result"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will keep CPU intense work from being performed in the reducer, and hence not on the main"},{"type":"text","text":" "},{"type":"text","text":"thread."}]},{"anchor":"High-frequency-actions","level":3,"type":"heading","text":"High-frequency actions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sending actions in a Composable Architecture application should not be thought as simple method"},{"type":"text","text":" "},{"type":"text","text":"calls that one does with classes, such as "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" conformances. When an action is sent"},{"type":"text","text":" "},{"type":"text","text":"into the system there are multiple layers of features that can intercept and interpret it, and"},{"type":"text","text":" "},{"type":"text","text":"the resulting state changes can reverberate throughout the entire application."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of this, sending actions does come with a cost. You should aim to only send “significant”"},{"type":"text","text":" "},{"type":"text","text":"actions into the system, that is, actions that cause the execution of important logic and effects"},{"type":"text","text":" "},{"type":"text","text":"for your application. High-frequency actions, such as sending dozens of actions per second,"},{"type":"text","text":" "},{"type":"text","text":"should be avoided unless your application truly needs that volume of actions in order to implement"},{"type":"text","text":" "},{"type":"text","text":"its logic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there are often times that actions are sent at a high frequency but the reducer doesn’t"},{"type":"text","text":" "},{"type":"text","text":"actually need that volume of information. For example, say you were constructing an effect that"},{"type":"text","text":" "},{"type":"text","text":"wanted to report its progress back to the system for each step of its work. You could choose to send"},{"type":"text","text":" "},{"type":"text","text":"the progress for literally every step:"}]},{"type":"codeListing","syntax":"swift","code":["case .startButtonTapped:","  return .run { send in","    var count = 0","    let max = await self.eventsClient.count()","","    for await event in self.eventsClient.events() {","      defer { count += 1 }","      send(.progress(Double(count) \/ Double(max)))","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, what if the effect required 10,000 steps to finish? Or 100,000? Or more? It would be"},{"type":"text","text":" "},{"type":"text","text":"immensely wasteful to send 100,000 actions into the system to report a progress value that is only"},{"type":"text","text":" "},{"type":"text","text":"going to vary from 0.0 to 1.0."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead, you can choose to report the progress every once in awhile. You can even do the math"},{"type":"text","text":" "},{"type":"text","text":"to make it so that you report the progress at most 100 times:"}]},{"type":"codeListing","syntax":"swift","code":["case .startButtonTapped:","  return .run { send in","    var count = 0","    let max = await self.eventsClient.count()","    let interval = max \/ 100","","    for await event in self.eventsClient.events() {","      defer { count += 1 }","      if count.isMultiple(of: interval) {","        send(.progress(Double(count) \/ Double(max)))","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This greatly reduces the bandwidth of actions being sent into the system so that you are not"},{"type":"text","text":" "},{"type":"text","text":"incurring unnecessary costs for sending actions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another example that comes up often is sliders. If done in the most direct way, by deriving a"},{"type":"text","text":" "},{"type":"text","text":"binding from the view store to hand to a "},{"type":"codeVoice","code":"Slider"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["Slider(value: viewStore.$opacity, in: 0...1)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will send an action into the system for every little change to the slider, which can be dozens"},{"type":"text","text":" "},{"type":"text","text":"or hundreds of actions as the user is dragging the slider. If this turns out to be problematic then"},{"type":"text","text":" "},{"type":"text","text":"you can consider alternatives."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, you can hold onto some local "},{"type":"codeVoice","code":"@State"},{"type":"text","text":" in the view for using with the "},{"type":"codeVoice","code":"Slider"},{"type":"text","text":", and"},{"type":"text","text":" "},{"type":"text","text":"then you can use the trailing "},{"type":"codeVoice","code":"onEditingChanged"},{"type":"text","text":" closure to send an action to the store:"}]},{"type":"codeListing","syntax":"swift","code":["Slider(value: self.$opacity, in: 0...1) {","  self.store.send(.setOpacity(self.opacity))","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This way an action is only sent once the user stops moving the slider."}]},{"anchor":"Store-scoping","level":3,"type":"heading","text":"Store scoping"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the 1.5.6 release of the library a change was made to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store\/scope(state:action:)-90255"},{"type":"text","text":" that"},{"type":"text","text":" "},{"type":"text","text":"made it more sensitive to performance considerations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most common form of scoping, that of scoping directly along boundaries of child features, is"},{"type":"text","text":" "},{"type":"text","text":"the most performant form of scoping and is the intended use of scoping. The library is slowly"},{"type":"text","text":" "},{"type":"text","text":"evolving to a state where that is the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"only"}]},{"type":"text","text":" kind of scoping one can do on a store."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The simplest example of this directly scoping to some child state and actions for handing to a"},{"type":"text","text":" "},{"type":"text","text":"child view:"}]},{"type":"codeListing","syntax":"swift","code":["ChildView(","  store: store.scope(state: \\.child, action: \\.child)",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another example is scoping to some collection of a child domain in order to use with"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ForEachStore"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["ForEachStore(store.scope(state: \\.rows, action: \\.rows)) { store in","  RowView(store: store)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And similarly for "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/IfLetStore"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwitchStore"},{"type":"text","text":". And finally, scoping to a child domain to be"},{"type":"text","text":" "},{"type":"text","text":"used with one of the libraries navigation view modifiers, such as"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwiftUI\/View\/sheet(store:onDismiss:content:)"},{"type":"text","text":", also falls under the intended use of scope:"}]},{"type":"codeListing","syntax":"swift","code":[".sheet(store: store.scope(state: \\.child, action: \\.child)) { store in","  ChildView(store: store)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of these examples are how "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store\/scope(state:action:)-90255"},{"type":"text","text":" is intended to be used, and you"},{"type":"text","text":" "},{"type":"text","text":"can continue using it in this way with no performance concerns."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Where performance can become a concern is when using "},{"type":"codeVoice","code":"scope"},{"type":"text","text":" on "},{"type":"emphasis","inlineContent":[{"type":"text","text":"computed"}]},{"type":"text","text":" properties rather than"},{"type":"text","text":" "},{"type":"text","text":"simple stored fields. For example, say you had a computed property in the parent feature’s state"},{"type":"text","text":" "},{"type":"text","text":"for deriving the child state:"}]},{"type":"codeListing","syntax":"swift","code":["extension ParentFeature.State {","  var computedChild: ChildFeature.State {","    ChildFeature.State(","      \/\/ Heavy computation here...","    )","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then in the view, say you scoped along that computed property:"}]},{"type":"codeListing","syntax":"swift","code":["ChildView(","  store: store.scope(state: \\.computedChild, action: \\.child)",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the computation in that property is heavy, it is going to become exacerbated by the changes"},{"type":"text","text":" "},{"type":"text","text":"made in 1.5, and the problem worsens the closer the scoping is to the root of the application."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The problem is that in version 1.5 scoped stores stopped directly holding onto their local state,"},{"type":"text","text":" "},{"type":"text","text":"and instead hold onto a reference to the store at the root of the application. And when you access"},{"type":"text","text":" "},{"type":"text","text":"state from the scoped store, it transforms the root state to the child state on the fly."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This transformation will include the heavy computed property, and potentially compute it many times"},{"type":"text","text":" "},{"type":"text","text":"if you need to access multiple pieces of state from the store. If you are noticing a performance"},{"type":"text","text":" "},{"type":"text","text":"problem while depending on 1.5+ of the library, look through your code base for any place you are"},{"type":"text","text":" "},{"type":"text","text":"using computed properties in scopes. You can even put a "},{"type":"codeVoice","code":"print"},{"type":"text","text":" statement in the computed property"},{"type":"text","text":" "},{"type":"text","text":"so that you can see first hand just how many times it is being invoked while running your"},{"type":"text","text":" "},{"type":"text","text":"application."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To fix the problem we recommend using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store\/scope(state:action:)-90255"},{"type":"text","text":" only along stored"},{"type":"text","text":" "},{"type":"text","text":"properties of child features. Such key paths are simple getters, and so not have a problem with"},{"type":"text","text":" "},{"type":"text","text":"performance. If you are using a computed property in a scope, then reconsider if that could instead"},{"type":"text","text":" "},{"type":"text","text":"be done along a plain, stored property and moving the computed logic into the child view. The"},{"type":"text","text":" "},{"type":"text","text":"further you push the computation towards the leaf nodes of your application, the less performance"},{"type":"text","text":" "},{"type":"text","text":"problems you will see."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/performance"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Performance","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SharingState"],"generated":true}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/SharingState":{"role":"collectionGroup","title":"Sharing state","abstract":[{"type":"text","text":"Learn techniques for sharing state throughout many parts of your application, and how to persist"},{"type":"text","text":" "},{"type":"text","text":"data to user defaults, the file system, and other external mediums."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SharingState","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/sharingstate"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"role":"symbol","title":"Effect","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"abstract":[],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Effect"}],"url":"\/documentation\/composablearchitecture\/effect"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ForEachStore":{"deprecated":true,"role":"symbol","title":"ForEachStore","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ForEachStore"}],"abstract":[{"type":"text","text":"A Composable Architecture-friendly wrapper around "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":" that simplifies working with"},{"type":"text","text":" "},{"type":"text","text":"collections of state."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ForEachStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ForEachStore"}],"url":"\/documentation\/composablearchitecture\/foreachstore"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/SwitchStore":{"deprecated":true,"role":"symbol","title":"SwitchStore","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SwitchStore"}],"abstract":[{"type":"text","text":"A view that observes when enum state held in a store changes cases, and provides stores to"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/CaseLet"},{"type":"text","text":" views."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwitchStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SwitchStore"}],"url":"\/documentation\/composablearchitecture\/switchstore"},"#Sharing-logic-with-actions":{"title":"Sharing logic with actions","titleInlineContent":[{"type":"text","text":"Sharing logic with actions"}],"type":"link","identifier":"#Sharing-logic-with-actions","url":"#Sharing-logic-with-actions"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyManagement":{"role":"article","title":"Dependencies","abstract":[{"type":"text","text":"Learn how to register dependencies with the library so that they can be immediately accessible from"},{"type":"text","text":" "},{"type":"text","text":"any reducer."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/dependencymanagement"},"#CPU-intensive-calculations":{"title":"CPU-intensive calculations","titleInlineContent":[{"type":"text","text":"CPU-intensive calculations"}],"type":"link","identifier":"#CPU-intensive-calculations","url":"#CPU-intensive-calculations"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/SwiftUI/View/sheet(store:onDismiss:content:)":{"role":"symbol","title":"sheet(store:onDismiss:content:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"sheet"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"State"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Action"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Content"},{"kind":"text","text":">("},{"kind":"externalParam","text":"store"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Store","preciseIdentifier":"s:22ComposableArchitecture5StoreC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"PresentationState","preciseIdentifier":"s:22ComposableArchitecture17PresentationStateV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"PresentationAction","preciseIdentifier":"s:22ComposableArchitecture18PresentationActionO"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":">>, "},{"kind":"externalParam","text":"onDismiss"},{"kind":"text","text":": (() -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"content"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"Store","preciseIdentifier":"s:22ComposableArchitecture5StoreC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"Content"},{"kind":"text","text":") -> "},{"kind":"keyword","text":"some"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"View","preciseIdentifier":"s:7SwiftUI4ViewP"}],"abstract":[{"type":"text","text":"Presents a sheet using the given store as a data source for the sheet’s content."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwiftUI\/View\/sheet(store:onDismiss:content:)","kind":"symbol","type":"topic","deprecated":true,"url":"\/documentation\/composablearchitecture\/swiftui\/view\/sheet(store:ondismiss:content:)"},"#High-frequency-actions":{"title":"High-frequency actions","titleInlineContent":[{"type":"text","text":"High-frequency actions"}],"type":"link","identifier":"#High-frequency-actions","url":"#High-frequency-actions"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Store/scope(state:action:)-90255":{"role":"symbol","title":"scope(state:action:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"scope"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"ChildState"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"ChildAction"},{"kind":"text","text":">("},{"kind":"externalParam","text":"state"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"KeyPath","preciseIdentifier":"s:s7KeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ChildState"},{"kind":"text","text":">, "},{"kind":"externalParam","text":"action"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"CaseKeyPath","preciseIdentifier":"s:9CasePaths0A7KeyPatha"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ChildAction"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"Store","preciseIdentifier":"s:22ComposableArchitecture5StoreC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"ChildState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ChildAction"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Scopes the store to one that exposes child state and actions."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store\/scope(state:action:)-90255","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/testing"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/CaseLet":{"deprecated":true,"role":"symbol","title":"CaseLet","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CaseLet"}],"abstract":[{"type":"text","text":"A view that handles a specific case of enum state in a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwitchStore"},{"type":"text","text":"."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/CaseLet","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CaseLet"}],"url":"\/documentation\/composablearchitecture\/caselet"},"#Store-scoping":{"title":"Store scoping","titleInlineContent":[{"type":"text","text":"Store scoping"}],"type":"link","identifier":"#Store-scoping","url":"#Store-scoping"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Performance#Sharing-logic-with-actions":{"abstract":[],"title":"Sharing logic with actions","kind":"section","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance#Sharing-logic-with-actions","url":"\/documentation\/composablearchitecture\/performance#Sharing-logic-with-actions"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"role":"symbol","title":"Reducer","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"abstract":[{"type":"text","text":"A protocol that describes how to evolve the current state of an application to the next state,"},{"type":"text","text":" "},{"type":"text","text":"given an action, and describes what "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect"},{"type":"text","text":"s should be executed later by the store, if any."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"url":"\/documentation\/composablearchitecture\/reducer"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Navigation":{"role":"collectionGroup","title":"Navigation","abstract":[{"type":"text","text":"Learn how to use the navigation tools in the library, including how to best model your domains, how"},{"type":"text","text":" "},{"type":"text","text":"to integrate features in the reducer and view layers, and how to write tests."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/IfLetStore":{"deprecated":true,"role":"symbol","title":"IfLetStore","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IfLetStore"}],"abstract":[{"type":"text","text":"A view that safely unwraps a store of optional state in order to show one of two views."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/IfLetStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IfLetStore"}],"url":"\/documentation\/composablearchitecture\/ifletstore"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"role":"article","title":"Getting started","abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingstarted"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"}}}