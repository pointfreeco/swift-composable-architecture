{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Adding-the-Composable-Architecture-as-a-dependency","level":2,"type":"heading","text":"Adding the Composable Architecture as a dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To use the Composable Architecture in a SwiftPM project, add it to the dependencies of your"},{"type":"text","text":" "},{"type":"text","text":"Package.swift and specify the "},{"type":"codeVoice","code":"ComposableArchitecture"},{"type":"text","text":" product in any targets that need access to"},{"type":"text","text":" "},{"type":"text","text":"the library:"}]},{"type":"codeListing","syntax":"swift","code":["let package = Package(","  dependencies: [","    .package(","      url: \"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\",","      from: \"0.34.0\"","    ),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [","        .product(","          name: \"ComposableArchitecture\",","          package: \"swift-composable-architecture\"","        )","      ]","    )","  ]",")"]},{"anchor":"Writing-your-first-feature","level":2,"type":"heading","text":"Writing your first feature"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To build a feature using the Composable Architecture you define some types and values that model"},{"type":"text","text":" "},{"type":"text","text":"your domain:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State"}]},{"type":"text","text":": A type that describes the data your feature needs to perform its logic and render its"},{"type":"text","text":" "},{"type":"text","text":"UI."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Action"}]},{"type":"text","text":": A type that represents all of the actions that can happen in your feature, such as"},{"type":"text","text":" "},{"type":"text","text":"user actions, notifications, event sources and more."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Environment"}]},{"type":"text","text":": A type that holds any dependencies the feature needs, such as API clients,"},{"type":"text","text":" "},{"type":"text","text":"analytics clients, etc."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Reducer"}]},{"type":"text","text":": A function that describes how to evolve the current state of the app to the next"},{"type":"text","text":" "},{"type":"text","text":"state given an action. The reducer is also responsible for returning any effects that should be"},{"type":"text","text":" "},{"type":"text","text":"run, such as API requests, which can be done by returning an "},{"type":"codeVoice","code":"Effect"},{"type":"text","text":" value."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Store"}]},{"type":"text","text":": The runtime that actually drives your feature. You send all user actions to the store"},{"type":"text","text":" "},{"type":"text","text":"so that the store can run the reducer and effects, and you can observe state changes in the"},{"type":"text","text":" "},{"type":"text","text":"store so that you can update UI."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The benefits of doing this is that you will instantly unlock testability of your feature, and you"},{"type":"text","text":" "},{"type":"text","text":"will be able to break large, complex features into smaller domains that can be glued together."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As a basic example, consider a UI that shows a number along with “+” and “−” buttons that increment"},{"type":"text","text":" "},{"type":"text","text":"and decrement the number. To make things interesting, suppose there is also a button that when"},{"type":"text","text":" "},{"type":"text","text":"tapped makes an API request to fetch a random fact about that number and then displays the fact in"},{"type":"text","text":" "},{"type":"text","text":"an alert."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The state of this feature would consist of an integer for the current count, as well as an optional"},{"type":"text","text":" "},{"type":"text","text":"string that represents the title of the alert we want to show (optional because "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" represents not"},{"type":"text","text":" "},{"type":"text","text":"showing an alert):"}]},{"type":"codeListing","syntax":"swift","code":["struct AppState: Equatable {","  var count = 0","  var numberFactAlert: String?","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next we have the actions in the feature. There are the obvious actions, such as tapping the"},{"type":"text","text":" "},{"type":"text","text":"decrement button, increment button, or fact button. But there are also some slightly non-obvious"},{"type":"text","text":" "},{"type":"text","text":"ones, such as the action of the user dismissing the alert, and the action that occurs when we"},{"type":"text","text":" "},{"type":"text","text":"receive a response from the fact API request:"}]},{"type":"codeListing","syntax":"swift","code":["enum AppAction: Equatable {","  case factAlertDismissed","  case decrementButtonTapped","  case incrementButtonTapped","  case numberFactButtonTapped","  case numberFactResponse(Result<String, ApiError>)","}","","struct ApiError: Error, Equatable {}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next we model the environment of dependencies this feature needs to do its job. In particular, to"},{"type":"text","text":" "},{"type":"text","text":"fetch a number fact we need to construct an "},{"type":"codeVoice","code":"Effect"},{"type":"text","text":" value that encapsulates the network request."},{"type":"text","text":" "},{"type":"text","text":"So that dependency is a function from "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Effect<String, ApiError>"},{"type":"text","text":", where "},{"type":"codeVoice","code":"String"},{"type":"text","text":" represents"},{"type":"text","text":" "},{"type":"text","text":"the response from the request. Further, the effect will typically do its work on a background thread"},{"type":"text","text":" "},{"type":"text","text":"(as is the case with "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":"), and so we need a way to receive the effect’s values on the main"},{"type":"text","text":" "},{"type":"text","text":"queue. We do this via a main queue scheduler, which is a dependency that is important to control so"},{"type":"text","text":" "},{"type":"text","text":"that we can write tests. We must use an "},{"type":"codeVoice","code":"AnyScheduler"},{"type":"text","text":" so that we can use a live "},{"type":"codeVoice","code":"DispatchQueue"},{"type":"text","text":" in"},{"type":"text","text":" "},{"type":"text","text":"production and a test scheduler in tests."}]},{"type":"codeListing","syntax":"swift","code":["struct AppEnvironment {","  var mainQueue: AnySchedulerOf<DispatchQueue>","  var numberFact: (Int) -> Effect<String, ApiError>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we implement a reducer that implements the logic for this domain. It describes how to change"},{"type":"text","text":" "},{"type":"text","text":"the current state to the next state, and describes what effects need to be executed. Some actions"},{"type":"text","text":" "},{"type":"text","text":"don’t need to execute effects, and they can return "},{"type":"codeVoice","code":".none"},{"type":"text","text":" to represent that:"}]},{"type":"codeListing","syntax":"swift","code":["let appReducer = Reducer<AppState, AppAction, AppEnvironment> { state, action, environment in","  switch action {","  case .factAlertDismissed:","    state.numberFactAlert = nil","    return .none","","  case .decrementButtonTapped:","    state.count -= 1","    return .none","","  case .incrementButtonTapped:","    state.count += 1","    return .none","","  case .numberFactButtonTapped:","    return environment.numberFact(state.count)","      .receive(on: environment.mainQueue)","      .catchToEffect(AppAction.numberFactResponse)","","  case let .numberFactResponse(.success(fact)):","    state.numberFactAlert = fact","    return .none","","  case .numberFactResponse(.failure):","    state.numberFactAlert = \"Could not load a number fact :(\"","    return .none","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then finally we define the view that displays the feature. It holds onto a"},{"type":"text","text":" "},{"type":"codeVoice","code":"Store<AppState, AppAction>"},{"type":"text","text":" so that it can observe all changes to the state and re-render, and we"},{"type":"text","text":" "},{"type":"text","text":"can send all user actions to the store so that state changes. We must also introduce a struct"},{"type":"text","text":" "},{"type":"text","text":"wrapper around the fact alert to make it "},{"type":"codeVoice","code":"Identifiable"},{"type":"text","text":", which the "},{"type":"codeVoice","code":".alert"},{"type":"text","text":" view modifier requires:"}]},{"type":"codeListing","syntax":"swift","code":["struct AppView: View {","  let store: Store<AppState, AppAction>","","  var body: some View {","    WithViewStore(self.store) { viewStore in","      VStack {","        HStack {","          Button(\"−\") { viewStore.send(.decrementButtonTapped) }","          Text(\"\\(viewStore.count)\")","          Button(\"+\") { viewStore.send(.incrementButtonTapped) }","        }","","        Button(\"Number fact\") { viewStore.send(.numberFactButtonTapped) }","      }","      .alert(","        item: viewStore.binding(","          get: { $0.numberFactAlert.map(FactAlert.init(title:)) },","          send: .factAlertDismissed","        ),","        content: { Alert(title: Text($0.title)) }","      )","    }","  }","}","","struct FactAlert: Identifiable {","  var title: String","  var id: String { self.title }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s important to note that we were able to implement this entire feature without having a real,"},{"type":"text","text":" "},{"type":"text","text":"live effect at hand. This is important because it means features can be built in isolation without"},{"type":"text","text":" "},{"type":"text","text":"building their dependencies, which can help compile times."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we are ready to display this view, for example in the scene delegate, we can construct a store."},{"type":"text","text":" "},{"type":"text","text":"This is the moment where we need to supply the dependencies, and for now we can just use an effect"},{"type":"text","text":" "},{"type":"text","text":"that immediately returns a mocked string:"}]},{"type":"codeListing","syntax":"swift","code":["let appView = AppView(","  store: Store(","    initialState: AppState(),","    reducer: appReducer,","    environment: AppEnvironment(","      mainQueue: .main,","      numberFact: { number in","        Effect(value: \"\\(number) is a good number Brent\")","      }","    )","  )",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And that is enough to get something on the screen to play around with. It’s definitely a few more"},{"type":"text","text":" "},{"type":"text","text":"steps than if you were to do this in a vanilla SwiftUI way, but there are a few benefits. It gives"},{"type":"text","text":" "},{"type":"text","text":"us a consistent manner to apply state mutations, instead of scattering logic in some observable"},{"type":"text","text":" "},{"type":"text","text":"objects and in various action closures of UI components. It also gives us a concise way of"},{"type":"text","text":" "},{"type":"text","text":"expressing side effects. And we can immediately test this logic, including the effects, without"},{"type":"text","text":" "},{"type":"text","text":"doing much additional work."}]},{"anchor":"Testing-your-feature","level":2,"type":"heading","text":"Testing your feature"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To test, you first create a "},{"type":"codeVoice","code":"TestStore"},{"type":"text","text":" with the same information that you would to create a regular"},{"type":"text","text":" "},{"type":"codeVoice","code":"Store"},{"type":"text","text":", except this time we can supply test-friendly dependencies. In particular, we use a test"},{"type":"text","text":" "},{"type":"text","text":"scheduler instead of the live "},{"type":"codeVoice","code":"DispatchQueue.main"},{"type":"text","text":" scheduler because that allows us to control when"},{"type":"text","text":" "},{"type":"text","text":"work is executed, and we don’t have to artificially wait for queues to catch up."}]},{"type":"codeListing","syntax":"swift","code":["let scheduler = DispatchQueue.test","","let store = TestStore(","  initialState: AppState(),","  reducer: appReducer,","  environment: AppEnvironment(","    mainQueue: scheduler.eraseToAnyScheduler(),","    numberFact: { number in Effect(value: \"\\(number) is a good number Brent\") }","  )",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once the test store is created we can use it to make an assertion of an entire user flow of steps."},{"type":"text","text":" "},{"type":"text","text":"Each step of the way we need to prove that state changed how we expect. Further, if a step causes an"},{"type":"text","text":" "},{"type":"text","text":"effect to be executed, which feeds data back into the store, we must assert that those actions were"},{"type":"text","text":" "},{"type":"text","text":"received properly."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The test below has the user increment and decrement the count, then they ask for a number fact, and"},{"type":"text","text":" "},{"type":"text","text":"the response of that effect triggers an alert to be shown, and then dismissing the alert causes the"},{"type":"text","text":" "},{"type":"text","text":"alert to go away."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Test that tapping on the increment\/decrement buttons changes the count","store.send(.incrementButtonTapped) {","  $0.count = 1","}","store.send(.decrementButtonTapped) {","  $0.count = 0","}","","\/\/ Test that tapping the fact button causes us to receive a response from the","\/\/ effect. Note that we have to advance the scheduler because we used","\/\/ `.receive(on:)` in the reducer.","store.send(.numberFactButtonTapped)","","scheduler.advance()","store.receive(.numberFactResponse(.success(\"0 is a good number Brent\"))) {","  $0.numberFactAlert = \"0 is a good number Brent\"","}","","\/\/ And finally dismiss the alert","store.send(.factAlertDismissed) {","  $0.numberFactAlert = nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is the basics of building and testing a feature in the Composable Architecture. There are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"a"},{"type":"text","text":" "},{"type":"text","text":"lot"}]},{"type":"text","text":" more things to be explored, such as composition, modularity, adaptability, and complex effects."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Getting Started","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"references":{"doc://co.pointfree.ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/co.pointfree.ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"}}}